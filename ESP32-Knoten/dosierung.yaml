################################################################################
# DiXY RDWC Controller - Dosierknoten v0.2-beta
# 
# Funktion: Intelligente Auto-Dosierung + RÃ¼hrmotor-Steuerung + Safety Management
# Hardware: ESP32-DevKit
# 
# GPIO PINOUT:
# â”œâ”€ SPI Bus (fÃ¼r MCP4131 Digitale Potentiometer):
# â”‚  â”œâ”€ GPIO2: SCK (Serial Clock)
# â”‚  â”œâ”€ GPIO3: MOSI (Master Out Slave In)
# â”‚  â”œâ”€ GPIO1: CS Pin (Inline-Fan Poti)
# â”‚  â””â”€ GPIO4: CS Pin (RÃ¼hrmotor Poti)
# â”œâ”€ Peristaltikpumpen (LEDC PWM):
# â”‚  â”œâ”€ GPIO12: Pumpe A (EC HauptdÃ¼nger - Flora Gro/Micro/Bloom)
# â”‚  â”œâ”€ GPIO13: Pumpe B (pH Down - PhosphorsÃ¤ure)
# â”‚  â”œâ”€ GPIO14: Pumpe C (pH Up - Kaliumhydroxid)
# â”‚  â””â”€ GPIO15: Pumpe D (Additive - CalMag/Enzyme/Vitamine)
# â””â”€ Status:
#    â””â”€ PWM-Steuerung via MCP4131 (0-255 = 0-100%)
# 
# Features v0.2:
# - EC/pH-Regelung mit Wirksamkeits-Berechnung (ml â†’ mS/cm bzw. pH)
# - RÃ¼hrzeit-Management (min. 3min zwischen Dosierungen)
# - Safety Limits (max ml/Tag, Ãœberdosierungs-Schutz)
# - Flow-Rate Kalibrierung (echte ml/s pro Pumpe)
# - Lifetime Statistics (Total ml, Runtime, Zyklen)
# - WiFi Diagnostics + Health Checks
################################################################################

substitutions:
  device_name: dosierung
  friendly_name: "Dosierung"
  device_description: "Intelligente Auto-Dosierung + Safety"
  project_version: "0.3-beta"
  
  # SPI Pins
  spi_clk_pin: "2"
  spi_mosi_pin: "3"
  mcp4131_fan_cs_pin: "1"
  mcp4131_stir_cs_pin: "4"
  
  # Pumpen GPIO Pins
  pump_a_pin: "12"  # EC HauptdÃ¼nger
  pump_b_pin: "13"  # pH Down
  pump_c_pin: "14"  # pH Up
  pump_d_pin: "15"  # Additive
  
  # Timing Defaults
  min_stir_time: "180"        # 3min Pflicht-RÃ¼hrzeit zwischen Dosierungen
  full_mix_time: "300"         # 5min fÃ¼r komplette RDWC-Durchmischung
  stir_duration: "90"          # 90s Standard RÃ¼hrmotor-Lauf
  
  # Safety Limits
  max_dose_per_cycle: "50"     # Max 50ml pro Dosierung
  max_ml_per_day: "200"        # Max 200ml/Tag pro Pumpe

esphome:
  name: dosierung
  friendly_name: Dosierung
  comment: "DiXY Dosierknoten v0.2-beta â€“ Intelligente EC/pH-Regelung + RÃ¼hrzeit-Management + Safety Limits"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# ===============================================================
# SPI BUS (fÃ¼r MCP4131 Digitale Potentiometer)
# ===============================================================
# MCP4131 steuert PWM fÃ¼r Inline-Fan und RÃ¼hrmotor
# via digitale Potentiometer (0-255 Werte = 0-100%)
# ===============================================================
spi:
  id: spi_mcp
  clk_pin: ${spi_clk_pin}
  mosi_pin: ${spi_mosi_pin}
  # MISO wird nicht benÃ¶tigt fÃ¼r MCP4131 Write-Only

# ===============================================================
# LOGGING
# ===============================================================
logger:
  level: INFO
  baud_rate: 115200

# ===============================================================
# NETZWERK & AUTHENTIFIZIERUNG
# ===============================================================
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret dosierung_ap_ssid
    password: !secret dosierung_ap_password

api:
  reboot_timeout: 0s

ota:
  platform: esphome
  password: !secret dosierung_ota_password

web_server:
  port: 80

time:
  - platform: homeassistant
    id: ha_time

# ===============================================================
# GLOBALS â€“ RÃœHRZEIT & COUNTER MANAGEMENT
# ===============================================================
globals:
  # Timestamp der letzten Dosierung (fÃ¼r RÃ¼hrzeit-Check)
  - id: last_dose_timestamp
    type: unsigned long
    initial_value: '0'
    # Unix ms seit letzter Dosierung

  # Tages-Counter (Reset um Mitternacht)
  - id: pump_a_total_today
    type: float
    initial_value: '0.0'

  - id: pump_b_total_today
    type: float
    initial_value: '0.0'

  - id: pump_c_total_today
    type: float
    initial_value: '0.0'

  - id: pump_d_total_today
    type: float
    initial_value: '0.0'

  # Lifetime Counter (persistent Ã¼ber Reboots)
  - id: pump_a_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_b_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_c_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_d_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  # Dosier-Zyklen Counter
  - id: pump_a_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_b_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_c_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_d_cycles
    type: int
    initial_value: '0'
    restore_value: yes

# ===============================================================
# SENSOREN: EC-Wert vom Hydroknoten (Home Assistant Integration)
# ===============================================================
# EC-Sensorwert wird vom Hydroknoten gemessen und Ã¼ber
# Home Assistant API in Echtzeit verfÃ¼gbar gemacht
# ===============================================================

sensor:
  # EC vom Hydroknoten abrufen
  - platform: homeassistant
    name: "EC Aktuell (von Hydroknoten)"
    id: ec_current
    entity_id: sensor.hydroknoten_ec_sensor
    accuracy_decimals: 2

  # pH vom Hydroknoten abrufen
  - platform: homeassistant
    name: "pH Aktuell (von Hydroknoten)"
    id: ph_current
    entity_id: sensor.hydroknoten_ph_sensor
    accuracy_decimals: 2
    
  # EC-Zielwert (von HA Input-Helper gesetzt)
  - platform: homeassistant
    name: "EC Zielwert"
    id: ec_target
    entity_id: input_number.ec_target
    accuracy_decimals: 2

  # pH-Zielwert (von HA Input-Helper gesetzt)
  - platform: homeassistant
    name: "pH Zielwert"
    id: ph_target
    entity_id: input_number.ph_target
    accuracy_decimals: 2

  # System-Volumen (von HA oder Hydroknoten)
  - platform: homeassistant
    name: "System Volumen Gesamt"
    id: system_volume_liters
    entity_id: input_number.rdwc_system_liters
    unit_of_measurement: "L"
    accuracy_decimals: 1
    # Fallback: Manuell in HA setzen (z.B. 80L)

  # --- SYSTEM-SENSOREN (echte ESP32 Hardware) ---
  - platform: wifi_signal
    id: dosier_wifi_signal
    name: "Dosierung â€“ WiFi Signal"
    unit_of_measurement: "dBm"
    state_class: measurement
    update_interval: 30s
    # Zeigt WLAN-SignalstÃ¤rke: -30 (sehr gut) bis -100 (sehr schwach)

  - platform: uptime
    name: "Dosierung â€“ Uptime"
    unit_of_measurement: "h"
    state_class: total_increasing
    update_interval: 60s
    # Zeigt wie lange der ESP32 lÃ¤uft (in Stunden)

  - platform: internal_temperature
    name: "Dosierung â€“ ESP32 Temperatur"
    unit_of_measurement: "Â°C"
    state_class: measurement
    update_interval: 30s
    # Interne Temperatur des Mikrocontrollers (25-90Â°C normalerweise)

  - platform: template
    name: "Dosierung â€“ Freier RAM"
    unit_of_measurement: "kB"
    state_class: measurement
    lambda: |-
      // Gibt verfÃ¼gbaren Speicher in Kilobytes aus
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0;
    update_interval: 60s
    # Ãœberwachung: unter 50 kB ist kritisch

  # --- PUMPEN-ZUSTAND SENSOREN ---
  # â•â•â• RÃœHRZEIT-TRACKING â•â•â•
  
  - platform: template
    name: "Zeit seit letzter Dosierung"
    id: time_since_last_dose
    unit_of_measurement: "s"
    state_class: measurement
    lambda: |-
      if (id(last_dose_timestamp) == 0) return 999999;  // Noch nie dosiert
      return (millis() - id(last_dose_timestamp)) / 1000.0;
    update_interval: 10s
  
  - platform: template
    name: "NÃ¤chste Dosierung in"
    id: next_dose_countdown
    unit_of_measurement: "s"
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      float remaining = min_wait - time_passed;
      if (remaining < 0) return 0;
      return remaining;
    update_interval: 5s
  
  - platform: template
    name: "Durchmischung Fortschritt"
    id: mix_progress
    unit_of_measurement: "%"
    lambda: |-
      float full_mix = id(full_system_mix_time).state;
      float time_passed = id(time_since_last_dose).state;
      float progress = (time_passed / full_mix) * 100.0;
      if (progress > 100) return 100;
      return progress;
    update_interval: 10s
  
  # â•â•â• TAGES-COUNTER (ml heute dosiert) â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ ml heute"
    id: pump_a_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    lambda: 'return id(pump_a_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe B â€“ ml heute"
    id: pump_b_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    lambda: 'return id(pump_b_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe C â€“ ml heute"
    id: pump_c_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    lambda: 'return id(pump_c_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe D â€“ ml heute"
    id: pump_d_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    lambda: 'return id(pump_d_total_today);'
    update_interval: 10s
  
  # â•â•â• LIFETIME STATISTICS â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Total Lifetime ml"
    id: pump_a_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    lambda: 'return id(pump_a_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe B â€“ Total Lifetime ml"
    id: pump_b_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    lambda: 'return id(pump_b_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe C â€“ Total Lifetime ml"
    id: pump_c_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    lambda: 'return id(pump_c_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe D â€“ Total Lifetime ml"
    id: pump_d_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    lambda: 'return id(pump_d_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe A â€“ Dosier-Zyklen"
    id: pump_a_cycles_sensor
    state_class: total_increasing
    lambda: 'return id(pump_a_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe B â€“ Dosier-Zyklen"
    id: pump_b_cycles_sensor
    state_class: total_increasing
    lambda: 'return id(pump_b_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe C â€“ Dosier-Zyklen"
    id: pump_c_cycles_sensor
    state_class: total_increasing
    lambda: 'return id(pump_c_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe D â€“ Dosier-Zyklen"
    id: pump_d_cycles_sensor
    state_class: total_increasing
    lambda: 'return id(pump_d_cycles);'
    update_interval: 60s

# ===============================================================
# INPUTS: EC-REGELUNG PARAMETER
# ===============================================================

number:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DÃœNGER-WIRKSAMKEIT (EC-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ EC pro ml/100L"
    id: pump_a_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.018
    restore_value: true
    # Flora Gro/Micro/Bloom: ~1.8 mS/cm pro 1ml in 100L
  
  - platform: template
    name: "Pumpe B â€“ EC pro ml/100L"
    id: pump_b_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # pH Down Ã¤ndert EC nicht (meist PhosphorsÃ¤ure)
  
  - platform: template
    name: "Pumpe C â€“ EC pro ml/100L"
    id: pump_c_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # pH Up Ã¤ndert EC nicht (meist Kaliumhydroxid)
  
  - platform: template
    name: "Pumpe D â€“ EC pro ml/100L"
    id: pump_d_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.008
    restore_value: true
    # CalMag/Additive: ~0.8 mS/cm pro 1ml in 100L
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # pH-WIRKSAMKEIT (pH-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "pH Down â€“ Ã„nderung pro ml/100L"
    id: ph_down_per_ml
    unit_of_measurement: "pH"
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.15
    restore_value: true
    # PhosphorsÃ¤ure 40%: -0.15 pH pro ml/100L (stark!)
  
  - platform: template
    name: "pH Up â€“ Ã„nderung pro ml/100L"
    id: ph_up_per_ml
    unit_of_measurement: "pH"
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.12
    restore_value: true
    # Kaliumhydroxid: +0.12 pH pro ml/100L
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FLOW-RATE KALIBRIERUNG (echte ml/s pro Pumpe)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Flow Rate"
    id: pump_a_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.5
    restore_value: true
    # Nach Kalibrierung: 60s pumpen = 150ml â†’ 2.5 ml/s
  
  - platform: template
    name: "Pumpe B â€“ Flow Rate"
    id: pump_b_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "Pumpe C â€“ Flow Rate"
    id: pump_c_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "Pumpe D â€“ Flow Rate"
    id: pump_d_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.0
    restore_value: true
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SAFETY LIMITS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Max ml/Tag"
    id: pump_a_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
  
  - platform: template
    name: "Pumpe B â€“ Max ml/Tag"
    id: pump_b_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
    # pH Down: Weniger Limit (nur Korrektur)
  
  - platform: template
    name: "Pumpe C â€“ Max ml/Tag"
    id: pump_c_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
  
  - platform: template
    name: "Pumpe D â€“ Max ml/Tag"
    id: pump_d_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
  
  - platform: template
    name: "Max Dosis pro Zyklus"
    id: max_dose_per_cycle
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 5
    max_value: 100
    step: 5
    initial_value: ${max_dose_per_cycle}
    restore_value: true
    # Schutz: Max 50ml pro Dosierung
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RÃœHRZEIT-MANAGEMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Min. RÃ¼hrzeit zwischen Dosierungen"
    id: min_stir_time_between_doses
    unit_of_measurement: "s"
    optimistic: true
    min_value: 60
    max_value: 600
    step: 10
    initial_value: ${min_stir_time}
    restore_value: true
    # 3min Pflicht-Durchmischung vor nÃ¤chster Dosierung
  
  - platform: template
    name: "Durchmischungs-Dauer (System-Zyklus)"
    id: full_system_mix_time
    unit_of_measurement: "s"
    optimistic: true
    min_value: 120
    max_value: 900
    step: 30
    initial_value: ${full_mix_time}
    restore_value: true
    # 5min = 1 kompletter RDWC-Umlauf
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # LEGACY PARAMETERS (werden nach v0.2 entfernt)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # EC-Sollwert (0.5-3.0 mS/cm)
  - platform: template
    id: ec_setpoint
    name: "EC Sollwert (mS/cm)"
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.5
    max_value: 3.0
    step: 0.1
    initial_value: 1.2
    restore_value: true
    
  # EC-Toleranzbereich (z.B. Â±0.2 mS/cm)
  - platform: template
    id: ec_tolerance
    name: "EC Toleranzbereich (Â±mS/cm)"
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.05
    max_value: 0.5
    step: 0.05
    initial_value: 0.2
    restore_value: true
    
  # Dosiervolumen pro Pumpen-Lauf (ml/min)
  - platform: template
    id: pump_volume_ec
    name: "Dosiervolumen EC-Pumpe (ml/min)"
    unit_of_measurement: "ml/min"
    optimistic: true
    min_value: 0.5
    max_value: 10.0
    step: 0.5
    initial_value: 2.0
    restore_value: true
    # EC/MakronÃ¤hrstoffe Dosierung (z.B. Flora Series)

  - platform: template
    id: pump2_speed
    name: "Pumpe 2 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # pH-Up oder pH-Down Dosierung

  - platform: template
    id: pump3_speed
    name: "Pumpe 3 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # MikronÃ¤hrstoffe Dosierung (z.B. Calmag, Vitamine)

  - platform: template
    id: pump4_speed
    name: "Pumpe 4 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # RÃ¼hrmotor Einstellungen
  - platform: template
    id: stir_time
    name: "RÃ¼hrmotor â€“ Dauer (Sekunden)"
    unit_of_measurement: "s"
    optimistic: true
    min_value: 30
    max_value: 300
    step: 10
    initial_value: 90
    restore_value: true
    # Wie lange RÃ¼hrmotor nach Dosierung lÃ¤uft (RDWC Durchmischung)

  - platform: template
    id: stir_speed
    name: "RÃ¼hrmotor â€“ PWM Speed"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 30
    max_value: 100
    step: 5
    initial_value: 60
    restore_value: true
    # PWM fÃ¼r RÃ¼hrmotor: 30-100% (mindestens 30% zum Starten)

# ===============================================================
# GPIO PIN DEFINITIONS FÃœR PWM & SPI
# ===============================================================
# GPIO Pins fÃ¼r PWM (Pulse Width Modulation) der Pumpen
# PWM steuert die Motorgeschwindigkeit (0-255 oder 0-100%)
# Frequency: 1000 Hz = typisch fÃ¼r Motorsteuerung
# MCP4131 via SPI: Inline-Fan (GPIO1 CS) + RÃ¼hrmotor (GPIO4 CS)
# ===============================================================
output:
  # PWM Output fÃ¼r Pumpe 1 (GPIO 12)
  - platform: ledc
    id: pump1_output
    pin: GPIO12
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Ausgangsspannung: 0-3.3V (PWM wird von Motor-Treiber verstÃ¤rkt)

  # PWM Output fÃ¼r Pumpe 2 (GPIO 13)
  - platform: ledc
    id: pump2_output
    pin: GPIO13
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 3 (GPIO 14)
  - platform: ledc
    id: pump3_output
    pin: GPIO14
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 4 (GPIO 15)
  - platform: ledc
    id: pump4_output
    pin: GPIO15
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # ===============================================================
  # MCP4131 DIGITALE POTENTIOMETER (SPI)
  # ===============================================================
  # FÃ¼r PWM-Steuerung von Inline-Fan und RÃ¼hrmotor
  # Wert: 0-255 = 0-100% Geschwindigkeit
  # ===============================================================

  # MCP4131 fÃ¼r Inline-Fan (CS=GPIO1)
  - platform: mcp4131
    id: mcp4131_fan
    cs_pin: GPIO1
    spi_id: spi_mcp
    channel: A
    unit_of_measurement: "%"
    # 0-100% PWM fÃ¼r Inline-Fan Durchflussregelung

  # MCP4131 fÃ¼r RÃ¼hrmotor (CS=GPIO4)
  - platform: mcp4131
    id: mcp4131_stir
    cs_pin: GPIO4
    spi_id: spi_mcp
    channel: A
    unit_of_measurement: "%"
    # 30-100% PWM fÃ¼r RÃ¼hrmotor (nach Dosierung)

# ===============================================================
# SCHALTER: PUMPEN-STEUERUNG (mit PWM-Geschwindigkeit)
# ===============================================================
# 4 Template-Switches fÃ¼r die Peristaltikpumpen
# Optimistic: true = schaltet sofort (BestÃ¤tigung wird nicht erwartet)
# Lambda konvertiert 0-100% in PWM-Duty-Cycle (0.0-1.0)
# ===============================================================
switch:
  - platform: template
    id: pump1_switch
    name: "Pumpe 1 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump1_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump1_output).set_level(duty_cycle);
        - logger.log: "Pumpe 1 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump1_output
            level: 0.0
        - logger.log: "Pumpe 1 AUS"

  - platform: template
    id: pump2_switch
    name: "Pumpe 2 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump2_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump2_output).set_level(duty_cycle);
        - logger.log: "Pumpe 2 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump2_output
            level: 0.0
        - logger.log: "Pumpe 2 AUS"

  - platform: template
    id: pump3_switch
    name: "Pumpe 3 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump3_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump3_output).set_level(duty_cycle);
        - logger.log: "Pumpe 3 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump3_output
            level: 0.0
        - logger.log: "Pumpe 3 AUS"

  - platform: template
    id: pump4_switch
    name: "Pumpe 4 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump4_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump4_output).set_level(duty_cycle);
        - logger.log: "Pumpe 4 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump4_output
            level: 0.0
        - logger.log: "Pumpe 4 AUS"

  # ===============================================================
  # RÃœHRMOTOR STEUERUNG (MCP4131 PWM)
  # ===============================================================
  # Wird automatisch nach Dosierung gestartet
  # Mischt NÃ¤hrstoffe im RDWC-System durch
  # ===============================================================

  - platform: template
    id: stir_motor_switch
    name: "RÃ¼hrmotor â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(stir_speed).state;
            // Min 30% fÃ¼r Motor-Startup
            if (speed_percent < 30.0) speed_percent = 30.0;
            // Max 100%
            if (speed_percent > 100.0) speed_percent = 100.0;
            // Umwandlung zu MCP4131 (0-255)
            uint8_t mcp_value = (uint8_t)(speed_percent * 2.55);
            id(mcp4131_stir).output_value(mcp_value);
        - logger.log: "RÃ¼hrmotor AN"
    turn_off_action:
      then:
        - lambda: |-
            id(mcp4131_stir).output_value(0);
        - logger.log: "RÃ¼hrmotor AUS"

# ===============================================================
# TEXT SENSOREN (WLAN-INFOS, VERSION, ZUSAMMENFASSUNGEN)
# ===============================================================
# Diese Sensoren zeigen Netzwerk-Infos und Status-Summaries
# NÃ¼tzlich fÃ¼r Dashboards und Debugging
# ===============================================================
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Dosierung â€“ IP"
    ssid:
      name: "Dosierung â€“ WLAN SSID"
    bssid:
      name: "Dosierung â€“ WLAN BSSID"
    mac_address:
      name: "Dosierung â€“ MAC"
    # Zeigt Netzwerk-Informationen an (IP, SSID, MAC-Adresse)

  - platform: version
    name: "ESPHome Version"

  - platform: template
    name: "Projekt Version"
    lambda: |-
      return {"v1.1.2"};
    update_interval: 60s

  - platform: template
    name: "Dosierung â€“ Status Zusammenfassung"
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Pumpe1: %.0f%% | Pumpe2: %.0f%% | Pumpe3: %.0f%% | Pumpe4: %.0f%% | RÃ¼hr: %.0f%%",
        id(pump1_speed).state,
        id(pump2_speed).state,
        id(pump3_speed).state,
        id(pump4_speed).state,
        id(stir_speed).state
      );
      return std::string(buffer);
    update_interval: 5s
    # Kompaktes Status-Dashboard: Drehzahlen aller 4 Pumpen + RÃ¼hrmotor

  - platform: template
    name: "Dosierung â€“ Pumpen Status"
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Pumpe 1: %s | Pumpe 2: %s | Pumpe 3: %s | Pumpe 4: %s | RÃ¼hr: %s",
        id(pump1_switch).state ? "AN" : "AUS",
        id(pump2_switch).state ? "AN" : "AUS",
        id(pump3_switch).state ? "AN" : "AUS",
        id(pump4_switch).state ? "AN" : "AUS",
        id(stir_motor_switch).state ? "AN" : "AUS"
      );
      return std::string(buffer);
    update_interval: 5s
    # Zeigt den Zustand aller 4 Pumpen + RÃ¼hrmotor: AN/AUS

# ===============================================================
# BINARY SENSOREN (HEALTH CHECKS, SAFETY ALARMS)
# ===============================================================

binary_sensor:
  # RÃ¼hrzeit Check (TRUE = Dosierung erlaubt)
  - platform: template
    name: "RÃ¼hrzeit abgelaufen"
    id: stir_time_elapsed
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      return time_passed >= min_wait;

  # Hydroknoten Online Check
  - platform: template
    name: "Hydroknoten Online"
    id: hydroknoten_online
    device_class: connectivity
    lambda: |-
      // Check ob EC-Wert aktualisiert wird (nicht NaN)
      return !isnan(id(ec_current).state) && !isnan(id(ph_current).state);

  # Safety Limits (90% Warnung)
  - platform: template
    name: "Pumpe A â€“ Safety Limit Warning"
    lambda: |-
      return id(pump_a_total_today) >= (id(pump_a_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe B â€“ Safety Limit Warning"
    lambda: |-
      return id(pump_b_total_today) >= (id(pump_b_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe C â€“ Safety Limit Warning"
    lambda: |-
      return id(pump_c_total_today) >= (id(pump_c_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe D â€“ Safety Limit Warning"
    lambda: |-
      return id(pump_d_total_today) >= (id(pump_d_max_ml_day).state * 0.9);

  # Irgendeine Pumpe aktiv?
  - platform: template
    name: "Dosierung aktiv"
    lambda: |-
        return id(pump1_switch).state || id(pump2_switch).state || 
               id(pump3_switch).state || id(pump4_switch).state;

# ===============================================================
# BUTTONS (RESTART, DAILY RESET)
# ===============================================================
button:
  - platform: restart
    name: "Dosierung â€“ Restart"

  - platform: safe_mode
    name: "Dosierung â€“ Safe Mode"

  - platform: template
    name: "Reset Tages-Counter"
    on_press:
      - logger.log: "ğŸ”„ Tages-Counter zurÃ¼ckgesetzt"
      - lambda: |-
          id(pump_a_total_today) = 0.0;
          id(pump_b_total_today) = 0.0;
          id(pump_c_total_today) = 0.0;
          id(pump_d_total_today) = 0.0;

# ===============================================================
# SCRIPTS (DOSIER-LOGIK, DAILY RESET)
# ===============================================================
script:
    - id: daily_reset_script
      mode: single
      then:
        - logger.log: "ğŸŒ… Mitternacht â€“ Tages-Counter Reset"
        - lambda: |-
            id(pump_a_total_today) = 0.0;
            id(pump_b_total_today) = 0.0;
            id(pump_c_total_today) = 0.0;
            id(pump_d_total_today) = 0.0;

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE EC-DOSIERUNG (Pumpe A)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ec_nutrients
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ EC-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ec_nutrients

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ EC-Dosierung abgebrochen"
              - script.stop: dose_ec_nutrients

        # STEP 3: EC-Berechnung
        - lambda: |-
            float ec_diff = id(ec_target).state - id(ec_current).state;

            if (ec_diff < 0.05) {
              ESP_LOGI("dose_ec", "âœ“ EC bereits im Zielbereich (%.2f mS/cm)", id(ec_current).state);
              return;
            }

            float system_liters = id(system_volume_liters).state;
            float ec_per_ml_100L = id(pump_a_ec_per_ml).state;
            float ec_per_ml_actual = ec_per_ml_100L * (100.0 / system_liters);
            float ml_needed = ec_diff / ec_per_ml_actual;

            float max_cycle = id(max_dose_per_cycle).state;
            if (ml_needed > max_cycle) {
              ESP_LOGW("dose_ec", "âš ï¸ Begrenzt auf %.0f ml (berechnet: %.1f ml)", max_cycle, ml_needed);
              ml_needed = max_cycle;
            }

            if (id(pump_a_total_today) + ml_needed > id(pump_a_max_ml_day).state) {
              ESP_LOGE("dose_ec", "âŒ Tageslimit erreicht! (%.0f/%.0f ml)", id(pump_a_total_today), id(pump_a_max_ml_day).state);
              return;
            }

            ESP_LOGI("dose_ec", "ğŸ’§ Dosiere %.1f ml DÃ¼nger (EC: %.2f â†’ %.2f mS/cm)", ml_needed, id(ec_current).state, id(ec_target).state);

            float flow_rate = id(pump_a_flow_ml_per_sec).state;
            float seconds = ml_needed / flow_rate;
            id(pump1_output).set_level(1.0);
            delay((int)(seconds * 1000));
            id(pump1_output).set_level(0.0);

            id(pump_a_total_today) += ml_needed;
            id(pump_a_lifetime_ml) += ml_needed;
            id(pump_a_cycles) += 1;
            id(last_dose_timestamp) = millis();

            ESP_LOGI("dose_ec", "âœ“ Pumpe A: %.1f ml dosiert (heute: %.0f ml)", ml_needed, id(pump_a_total_today));

        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            float speed_percent = id(stir_speed).state;
            if (speed_percent < 30.0) speed_percent = 30.0;
            uint8_t mcp_value = (uint8_t)(speed_percent * 2.55);
            id(mcp4131_stir).output_value(mcp_value);
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: 'id(mcp4131_stir).output_value(0);'
        - logger.log: "âœ“ EC-Dosierung + RÃ¼hrvorgang abgeschlossen"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE pH-DOSIERUNG (Pumpe B/C)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ph_correction
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ pH-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ph_correction

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ pH-Dosierung abgebrochen"
              - script.stop: dose_ph_correction

        # STEP 3: pH-Berechnung
        - lambda: |-
            float ph_diff = id(ph_target).state - id(ph_current).state;

            if (abs(ph_diff) < 0.1) {
              ESP_LOGI("dose_ph", "âœ“ pH bereits im Zielbereich (%.2f)", id(ph_current).state);
              return;
            }

            float system_liters = id(system_volume_liters).state;
            float ml_needed = 0.0;
            int pump_id = 0;

            if (ph_diff > 0.1) {
              float ph_per_ml_100L = id(ph_up_per_ml).state;
              float ph_per_ml_actual = ph_per_ml_100L * (100.0 / system_liters);
              ml_needed = ph_diff / ph_per_ml_actual;
              pump_id = 3;
              ESP_LOGI("dose_ph", "ğŸ“ˆ pH zu niedrig â€“ pH Up benÃ¶tigt");
            } else {
              float ph_per_ml_100L = id(ph_down_per_ml).state;
              float ph_per_ml_actual = ph_per_ml_100L * (100.0 / system_liters);
              ml_needed = abs(ph_diff) / ph_per_ml_actual;
              pump_id = 2;
              ESP_LOGI("dose_ph", "ğŸ“‰ pH zu hoch â€“ pH Down benÃ¶tigt");
            }

            float max_cycle = id(max_dose_per_cycle).state;
            if (ml_needed > max_cycle) {
              ESP_LOGW("dose_ph", "âš ï¸ Begrenzt auf %.0f ml (berechnet: %.1f ml)", max_cycle, ml_needed);
              ml_needed = max_cycle;
            }

            float* today_counter = (pump_id == 2) ? &id(pump_b_total_today) : &id(pump_c_total_today);
            float max_day = (pump_id == 2) ? id(pump_b_max_ml_day).state : id(pump_c_max_ml_day).state;

            if (*today_counter + ml_needed > max_day) {
              ESP_LOGE("dose_ph", "âŒ Tageslimit Pumpe %d erreicht!", pump_id);
              return;
            }

            ESP_LOGI("dose_ph", "ğŸ’§ Dosiere %.1f ml (pH: %.2f â†’ %.2f)", ml_needed, id(ph_current).state, id(ph_target).state);

            float flow_rate = (pump_id == 2) ? id(pump_b_flow_ml_per_sec).state : id(pump_c_flow_ml_per_sec).state;
            float seconds = ml_needed / flow_rate;

            if (pump_id == 2) {
              id(pump2_output).set_level(1.0);
              delay((int)(seconds * 1000));
              id(pump2_output).set_level(0.0);
              id(pump_b_total_today) += ml_needed;
              id(pump_b_lifetime_ml) += ml_needed;
              id(pump_b_cycles) += 1;
            } else {
              id(pump3_output).set_level(1.0);
              delay((int)(seconds * 1000));
              id(pump3_output).set_level(0.0);
              id(pump_c_total_today) += ml_needed;
              id(pump_c_lifetime_ml) += ml_needed;
              id(pump_c_cycles) += 1;
            }

            id(last_dose_timestamp) = millis();
            ESP_LOGI("dose_ph", "âœ“ Pumpe %d: %.1f ml dosiert", pump_id, ml_needed);
        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            float speed_percent = id(stir_speed).state;
            if (speed_percent < 30.0) speed_percent = 30.0;
            uint8_t mcp_value = (uint8_t)(speed_percent * 2.55);
            id(mcp4131_stir).output_value(mcp_value);
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: 'id(mcp4131_stir).output_value(0);'
        - logger.log: "âœ“ pH-Dosierung + RÃ¼hrvorgang abgeschlossen"
# ===============================================================
# INTERVAL (DAILY RESET UM 00:00)
# ===============================================================
interval:
  - interval: 1h
    then:
      - lambda: |-
          auto time = id(ha_time).now();
          if (time.hour == 0 && time.minute == 0) {
            id(daily_reset_script).execute();
          }
