################################################################################
# DiXY RDWC Dosierknoten v0.5-beta
#
# WHAT IT DOES
# - 4 Peristaltik-Pumpen fÃ¼r EC/pH Auto-Dosierung steuern
# - Berechnet aus echten Hydroknoten-Daten wie viel ml nÃ¶tig ist
# - Checkt: ist genug Zeit vergangen? Ist Hydroknoten online?
# - Respektiert Safety Limits (pro Tag, pro Zyklus)
# - RÃ¼hrmotor lÃ¤uft nach jeder Dosierung (Durchmischung)
#
# CRITICAL DEPENDENCIES
# - EC & pH Sensordaten vom Hydroknoten (via HA API)
# - System-Volumen muss in HA als input_number gesetzt sein
# - HA braucht Time-Service fÃ¼r tÃ¤gliche Counter-Resets
# FALLBACK: Ohne Hydroknoten geht gar nix (Dosierung blockiert)
#
# OPTIONAL DEPENDENCIES
# - HA fÃ¼r Logging (lokal mit Safety Limits funktioniert offline)
# - Buzzer auf GPIO27 (v0.6 geplant)
#
# HARDWARE
# - ESP32-DevKit + 4x Peristaltik-Pumpen + MCP4131 Potentiometer
# - SPI Bus fÃ¼r RÃ¼hrmotor & Inline-Fan PWM
# - PWM: GPIO12-15 fÃ¼r 4 Pumpen
#
# FEATURES v0.5
# - Health Monitoring V2 (Boot-Graceperiod 300s, Failure Counter)
# - EC/pH-Regelung mit Wirksamkeits-Berechnung
# - RÃ¼hrzeit-Management (min. 3min zwischen Dosierungen)
# - Safety Limits + Flow-Rate Kalibrierung
# - Lifetime Statistics (Total ml, Runtime, Zyklen)
# - WiFi Diagnostics + Reset Grund Detection
#
# SUBSTITUTION (easy hardware swapping)
# - Alle GPIO + I2C Adressen substituierbar
# - Kein hardcoding â†’ v1.0 Single-PCB Integration vorbereitet
#
# FUTURE (v1.0)
# - EC/pH kÃ¶nnten direkt vom lokalen ADS1115 kommen (statt HA)
# - Buzzer-Output einfach ergÃ¤nzbar
# - GPIO Pins leicht auf andere PCB-Pins ummappbar
################################################################################

substitutions:
  device_name: dosierung
  friendly_name: "Dosierung"
  device_description: "Intelligente Auto-Dosierung + Safety"
  project_version: "0.1"
  
  # SPI Pins
  spi_clk_pin: "2"
  spi_mosi_pin: "3"
  # mcp4131_fan_cs_pin: "1"
  # mcp4131_stir_cs_pin: "4"
  
  # Pumpen GPIO Pins
  pump_a_pin: "12"  # EC HauptdÃ¼nger
  pump_b_pin: "13"  # DÃ¼nger 2 (EC)
  pump_c_pin: "14"  # DÃ¼nger 3 (EC)
  pump_d_pin: "15"  # pH Down
  
  # Timing Defaults
  min_stir_time: "180"        # 3min Pflicht-RÃ¼hrzeit zwischen Dosierungen
  full_mix_time: "300"         # 5min fÃ¼r komplette RDWC-Durchmischung
  stir_duration: "90"          # 90s Standard RÃ¼hrmotor-Lauf
  
  # Safety Limits
  max_dose_per_cycle: "50"     # Max 50ml pro Dosierung
  max_ml_per_day: "200"        # Max 200ml/Tag pro Pumpe

esphome:
  name: dosierung
  friendly_name: Dosierung
  comment: "DiXY Dosierknoten v0.2-beta â€“ Intelligente EC/pH-Regelung + RÃ¼hrzeit-Management + Safety Limits"
  project:
    name: "loserat.dixy_dosierung"
    version: "2.6"
  on_boot:
    priority: -100.0
    then:
      - logger.log: "Dosierung gestartet. Version 2.6"
esp32:
  board: esp32dev
  framework:
    type: esp-idf

# ===============================================================
# SPI BUS (fÃ¼r MCP4131 Digitale Potentiometer)
# ===============================================================
# MCP4131 steuert PWM fÃ¼r Inline-Fan und RÃ¼hrmotor
# via digitale Potentiometer (0-255 Werte = 0-100%)
# ===============================================================
spi:
  id: spi_mcp
  clk_pin: ${spi_clk_pin}
  mosi_pin: ${spi_mosi_pin}
  # MISO wird nicht benÃ¶tigt fÃ¼r MCP4131 Write-Only

# ===============================================================
# LOGGING
# ===============================================================
logger:
  level: info
  baud_rate: 115200

# ===============================================================
# NETZWERK & AUTHENTIFIZIERUNG
# ===============================================================
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret dosierung_ap_ssid
    password: !secret dosierung_ap_password

api:
  reboot_timeout: 0s

ota:
  platform: esphome
  password: !secret dosierung_ota_password

web_server:
  port: 80

time:
  - platform: homeassistant
    id: ha_time

# ===============================================================
# GLOBALS â€“ RÃœHRZEIT & COUNTER MANAGEMENT
# ===============================================================
globals:
  # Timestamp der letzten Dosierung (fÃ¼r RÃ¼hrzeit-Check)
  - id: last_dose_timestamp
    type: unsigned long
    initial_value: '0'
    # Unix ms seit letzter Dosierung

  # Letzte Dosiermenge (ml)
  - id: last_dose_ml
    type: float
    initial_value: '0.0'

  # Letzter Dosiertyp: 0=keine, 1=EC, 2=pH
  - id: last_dose_kind
    type: int
    initial_value: '0'

  # Laufparameter fÃ¼r Pumpenlauf (nicht blockierend)
  - id: run_pump_id
    type: int
    initial_value: '0'

  - id: run_pump_seconds
    type: float
    initial_value: '0.0'

  - id: run_pump_ml
    type: float
    initial_value: '0.0'

  - id: run_pump_kind
    type: int
    initial_value: '0'

  - id: run_valid
    type: int
    initial_value: '0'

  - id: ec_active_pumps
    type: int
    initial_value: '0'

  - id: ec_share
    type: float
    initial_value: '0.0'

  - id: ec_should_stop
    type: int
    initial_value: '0'

  # Tages-Counter (Reset um Mitternacht)
  - id: pump_a_total_today
    type: float
    initial_value: '0.0'

  - id: pump_b_total_today
    type: float
    initial_value: '0.0'

  - id: pump_c_total_today
    type: float
    initial_value: '0.0'

  - id: pump_d_total_today
    type: float
    initial_value: '0.0'

  # Lifetime Counter (persistent Ã¼ber Reboots)
  - id: pump_a_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_b_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_c_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_d_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  # Dosier-Zyklen Counter
  - id: pump_a_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_b_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_c_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_d_cycles
    type: int
    initial_value: '0'
    restore_value: yes

# ===============================================================
# SENSOREN: EC-Wert vom Hydroknoten (Home Assistant Integration)
# ===============================================================
# EC-Sensorwert wird vom Hydroknoten gemessen und Ã¼ber
# Home Assistant API in Echtzeit verfÃ¼gbar gemacht
# ===============================================================

sensor:
  # EC vom Hydroknoten abrufen
  - platform: homeassistant
    name: "EC Aktuell (von Hydroknoten)"
    id: ec_current
    entity_id: sensor.hydroknoten_hydroknoten_ec_sensor
    accuracy_decimals: 2

  # pH vom Hydroknoten abrufen
  - platform: homeassistant
    name: "pH Aktuell (von Hydroknoten)"
    id: ph_current
    entity_id: sensor.hydroknoten_hydroknoten_ph_sensor
    accuracy_decimals: 2
    
  # --- SYSTEM-SENSOREN (echte ESP32 Hardware) ---
  - platform: wifi_signal
    id: dosier_wifi_signal
    name: "Dosierung WiFi Signal"
    unit_of_measurement: "dBm"
    state_class: measurement
    update_interval: 30s
    entity_category: diagnostic
    # Zeigt WLAN-SignalstÃ¤rke: -30 (sehr gut) bis -100 (sehr schwach)

  - platform: uptime
    name: "Dosierung Uptime"
    unit_of_measurement: "h"
    state_class: total_increasing
    update_interval: 60s
    entity_category: diagnostic
    # Zeigt wie lange der ESP32 lÃ¤uft (in Stunden)

  - platform: internal_temperature
    name: "Dosierung ESP32 Temperatur"
    unit_of_measurement: "Â°C"
    state_class: measurement
    update_interval: 30s
    entity_category: diagnostic
    # Interne Temperatur des Mikrocontrollers (25-90Â°C normalerweise)

  - platform: template
    name: "Dosierung Freier RAM"
    unit_of_measurement: "kB"
    state_class: measurement
    lambda: |-
      // Gibt verfÃ¼gbaren Speicher in Kilobytes aus
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0;
    update_interval: 60s
    entity_category: diagnostic
    # Ãœberwachung: unter 50 kB ist kritisch

  - platform: template
    name: "Dosierung Free Heap"
    unit_of_measurement: "kB"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: 'return (float)esp_get_free_heap_size() / 1024.0f;'
    entity_category: diagnostic
    # Alternative Free Heap Messung (kompatibel mit anderen Knoten)

  # --- PUMPEN-ZUSTAND SENSOREN ---
  # â•â•â• RÃœHRZEIT-TRACKING â•â•â•
  
  - platform: template
    name: "Zeit seit letzter Dosierung"
    id: time_since_last_dose
    unit_of_measurement: "s"
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      if (id(last_dose_timestamp) == 0) return 999999;  // Noch nie dosiert
      return (millis() - id(last_dose_timestamp)) / 1000.0;
    update_interval: 10s
  
  - platform: template
    name: "NÃ¤chste Dosierung in"
    id: next_dose_countdown
    unit_of_measurement: "s"
    entity_category: diagnostic
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      float remaining = min_wait - time_passed;
      if (remaining < 0) return 0;
      return remaining;
    update_interval: 5s

  - platform: template
    name: "Dosierung Wartezeit Rest (s)"
    unit_of_measurement: "s"
    entity_category: diagnostic
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      float remaining = min_wait - time_passed;
      if (remaining < 0) return 0;
      return remaining;
    update_interval: 2s
  
  - platform: template
    name: "Durchmischung Fortschritt"
    id: mix_progress
    unit_of_measurement: "%"
    entity_category: diagnostic
    lambda: |-
      float full_mix = id(full_system_mix_time).state;
      float time_passed = id(time_since_last_dose).state;
      float progress = (time_passed / full_mix) * 100.0;
      if (progress > 100) return 100;
      return progress;
    update_interval: 10s
  
  # â•â•â• TAGES-COUNTER (ml heute dosiert) â•â•â•
  
  - platform: template
    name: "Micro â€“ ml heute"
    id: pump_a_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_a_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Grow â€“ ml heute"
    id: pump_b_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_b_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Bloom â€“ ml heute"
    id: pump_c_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_c_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "pH Down â€“ ml heute"
    id: pump_d_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_d_total_today);'
    update_interval: 10s
  
  # â•â•â• LIFETIME STATISTICS â•â•â•
  
  - platform: template
    name: "Micro â€“ Total Lifetime ml"
    id: pump_a_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_a_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Grow â€“ Total Lifetime ml"
    id: pump_b_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_b_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Bloom â€“ Total Lifetime ml"
    id: pump_c_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_c_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "pH Down â€“ Total Lifetime ml"
    id: pump_d_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_d_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Micro â€“ Dosier-Zyklen"
    id: pump_a_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_a_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Grow â€“ Dosier-Zyklen"
    id: pump_b_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_b_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Bloom â€“ Dosier-Zyklen"
    id: pump_c_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_c_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "pH Down â€“ Dosier-Zyklen"
    id: pump_d_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_d_cycles);'
    update_interval: 60s

# ===============================================================
# INPUTS: EC-REGELUNG PARAMETER
# ===============================================================

number:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZIELWERTE (lokal am ESP bereitgestellt)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "EC Zielwert"
    id: ec_target
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.2
    max_value: 8.0
    step: 0.01
    initial_value: 3.0
    restore_value: true

  - platform: template
    name: "pH Zielwert"
    id: ph_target
    unit_of_measurement: "pH"
    optimistic: true
    min_value: 2.0
    max_value: 9.0
    step: 0.01
    initial_value: 6.0
    restore_value: true

  - platform: template
    name: "System Volumen Gesamt"
    id: system_volume_liters
    unit_of_measurement: "L"
    optimistic: true
    min_value: 10
    max_value: 200
    step: 1
    initial_value: 40
    restore_value: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DÃœNGER-WIRKSAMKEIT (EC-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Micro â€“ EC pro ml/100L"
    id: pump_a_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.225
    restore_value: true
    # Micro (Haupt-EC-Quelle)
  
  - platform: template
    name: "Grow â€“ EC pro ml/100L"
    id: pump_b_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.125
    restore_value: true
    # Grow (Stickstofflastig)
  
  - platform: template
    name: "Bloom â€“ EC pro ml/100L"
    id: pump_c_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.15
    restore_value: true
    # Bloom (PK-lastig)
  
  - platform: template
    name: "pH Down â€“ EC pro ml/100L"
    id: pump_d_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # pH Down: Keine EC-Wirksamkeit (nur pH-Korrektur)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # pH-WIRKSAMKEIT (pH-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "pH Down â€“ Ã„nderung pro ml/100L"
    id: ph_down_per_ml
    unit_of_measurement: "pH"
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.15
    restore_value: true
    # PhosphorsÃ¤ure 40%: -0.15 pH pro ml/100L (stark!)
  
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FLOW-RATE KALIBRIERUNG (echte ml/s pro Pumpe)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Micro â€“ Flow Rate"
    id: pump_a_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.5
    restore_value: true
    # Nach Kalibrierung: 60s pumpen = 150ml â†’ 2.5 ml/s
  
  - platform: template
    name: "Grow â€“ Flow Rate"
    id: pump_b_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "Bloom â€“ Flow Rate"
    id: pump_c_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "pH Down â€“ Flow Rate"
    id: pump_d_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.0
    restore_value: true
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SAFETY LIMITS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Micro â€“ Max ml/Tag"
    id: pump_a_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
  
  - platform: template
    name: "Grow â€“ Max ml/Tag"
    id: pump_b_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
    # DÃ¼nger 2 (EC)
  
  - platform: template
    name: "Bloom â€“ Max ml/Tag"
    id: pump_c_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
    # DÃ¼nger 3 (EC)
  
  - platform: template
    name: "pH Down â€“ Max ml/Tag"
    id: pump_d_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
    # pH Down
  
  - platform: template
    name: "Max Dosis pro Zyklus"
    id: max_dose_per_cycle
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 5
    max_value: 100
    step: 5
    initial_value: ${max_dose_per_cycle}
    restore_value: true
    # Schutz: Max 50ml pro Dosierung
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RÃœHRZEIT-MANAGEMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Min. RÃ¼hrzeit zwischen Dosierungen"
    id: min_stir_time_between_doses
    unit_of_measurement: "s"
    optimistic: true
    min_value: 1
    max_value: 600
    step: 10
    initial_value: ${min_stir_time}
    restore_value: true
    # 3min Pflicht-Durchmischung vor nÃ¤chster Dosierung
  
  - platform: template
    name: "Durchmischungs-Dauer (System-Zyklus)"
    id: full_system_mix_time
    unit_of_measurement: "s"
    optimistic: true
    min_value: 120
    max_value: 900
    step: 30
    initial_value: ${full_mix_time}
    restore_value: true
    # 5min = 1 kompletter RDWC-Umlauf
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # LEGACY PARAMETERS (werden nach v0.2 entfernt)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # EC-Toleranzbereich (z.B. Â±0.2 mS/cm)
  - platform: template
    id: ec_tolerance
    name: "EC Toleranzbereich (Â±mS/cm)"
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.05
    max_value: 0.5
    step: 0.05
    initial_value: 0.2
    restore_value: true
    
  # Dosiervolumen pro Pumpen-Lauf (ml/min)
  - platform: template
    id: pump_volume_ec
    name: "Dosiervolumen EC-Pumpe (ml/min)"
    unit_of_measurement: "ml/min"
    optimistic: true
    min_value: 0.5
    max_value: 10.0
    step: 0.5
    initial_value: 2.0
    restore_value: true
    # EC/MakronÃ¤hrstoffe Dosierung (z.B. Flora Series)

  - platform: template
    id: pump1_speed
    name: "Micro â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    # MakronÃ¤hrstoffe Dosierung (z.B. EC-A)

  - platform: template
    id: pump2_speed
    name: "Grow â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # pH-Up oder pH-Down Dosierung

  - platform: template
    id: pump3_speed
    name: "Bloom â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # MikronÃ¤hrstoffe Dosierung (z.B. Calmag, Vitamine)

  - platform: template
    id: pump4_speed
    name: "pH Down â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # RÃ¼hrmotor Einstellungen
  - platform: template
    id: stir_time
    name: "RÃ¼hrmotor â€“ Dauer (Sekunden)"
    unit_of_measurement: "s"
    optimistic: true
    min_value: 1
    max_value: 300
    step: 10
    initial_value: 90
    restore_value: true
    # Wie lange RÃ¼hrmotor nach Dosierung lÃ¤uft (RDWC Durchmischung)

  - platform: template
    id: stir_speed
    name: "RÃ¼hrmotor â€“ PWM Speed"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 30
    max_value: 100
    step: 5
    initial_value: 60
    restore_value: true
    # PWM fÃ¼r RÃ¼hrmotor: 30-100% (mindestens 30% zum Starten)

# ===============================================================
# GPIO PIN DEFINITIONS FÃœR PWM & SPI
# ===============================================================
# GPIO Pins fÃ¼r PWM (Pulse Width Modulation) der Pumpen
# PWM steuert die Motorgeschwindigkeit (0-255 oder 0-100%)
# Frequency: 1000 Hz = typisch fÃ¼r Motorsteuerung
# MCP4131 via SPI: Inline-Fan (GPIO1 CS) + RÃ¼hrmotor (GPIO4 CS)
# ===============================================================
output:
  # PWM Output fÃ¼r Pumpe 1 (GPIO 12)
  - platform: ledc
    id: pump1_output
    pin: GPIO12
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Ausgangsspannung: 0-3.3V (PWM wird von Motor-Treiber verstÃ¤rkt)

  # PWM Output fÃ¼r Pumpe 2 (GPIO 13)
  - platform: ledc
    id: pump2_output
    pin: GPIO13
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 3 (GPIO 14)
  - platform: ledc
    id: pump3_output
    pin: GPIO14
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 4 (GPIO 15)
  - platform: ledc
    id: pump4_output
    pin: GPIO15
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # ===============================================================
  # MCP4131 DIGITALE POTENTIOMETER (SPI) - DEAKTIVIERT
  # ===============================================================
  # TODO: Aktivieren, sobald die Hardware vorhanden ist.

# ===============================================================
# SCHALTER: PUMPEN-STEUERUNG (mit PWM-Geschwindigkeit)
# ===============================================================
# 4 Template-Switches fÃ¼r die Peristaltikpumpen
# Optimistic: true = schaltet sofort (BestÃ¤tigung wird nicht erwartet)
# Lambda konvertiert 0-100% in PWM-Duty-Cycle (0.0-1.0)
# ===============================================================
switch:
  - platform: template
    id: pump1_switch
    name: "Micro â€“ Steuerung"
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump1_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump1_output).set_level(duty_cycle);
        - logger.log: "Pumpe 1 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump1_output
            level: 0.0
        - logger.log: "Pumpe 1 AUS"

  - platform: template
    id: pump2_switch
    name: "Grow â€“ Steuerung"
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump2_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump2_output).set_level(duty_cycle);
        - logger.log: "Pumpe 2 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump2_output
            level: 0.0
        - logger.log: "Pumpe 2 AUS"

  - platform: template
    id: pump3_switch
    name: "Bloom â€“ Steuerung"
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump3_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump3_output).set_level(duty_cycle);
        - logger.log: "Pumpe 3 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump3_output
            level: 0.0
        - logger.log: "Pumpe 3 AUS"

  - platform: template
    id: pump4_switch
    name: "pH Down â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump4_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump4_output).set_level(duty_cycle);
        - logger.log: "Pumpe 4 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump4_output
            level: 0.0
        - logger.log: "Pumpe 4 AUS"

  # ===============================================================
  # RÃœHRMOTOR STEUERUNG (MCP4131 PWM)
  # ===============================================================
  # Wird automatisch nach Dosierung gestartet
  # Mischt NÃ¤hrstoffe im RDWC-System durch
  # ===============================================================

  - platform: template
    id: stir_motor_switch
    name: "RÃ¼hrmotor â€“ Steuerung"
    optimistic: true
    internal: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(stir_speed).state;
            // Min 30% fÃ¼r Motor-Startup
            if (speed_percent < 30.0) speed_percent = 30.0;
            // Max 100%
            if (speed_percent > 100.0) speed_percent = 100.0;
            // MCP4131 deaktiviert (Hardware fehlt).
        - logger.log: "RÃ¼hrmotor AN"
    turn_off_action:
      then:
        - logger.log: "RÃ¼hrmotor AUS blockiert (immer aktiv)"
        - switch.turn_on: stir_motor_switch

  # ===============================================================
  # SCHALTER: MANUELLE DOSIERUNG (START)
  # ===============================================================
  - platform: template
    id: dosierung_automatik
    name: "Dosierung Automatik"
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - logger.log: "âœ… Dosierung Automatik EIN"
    turn_off_action:
      then:
        - logger.log: "ğŸ›‘ Dosierung Automatik AUS"

# ===============================================================
# TEXT SENSOREN (WLAN-INFOS, VERSION, ZUSAMMENFASSUNGEN)
# ===============================================================
# Diese Sensoren zeigen Netzwerk-Infos und Status-Summaries
# NÃ¼tzlich fÃ¼r Dashboards und Debugging
# ===============================================================
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Dosierung IP"
      entity_category: diagnostic
    ssid:
      name: "Dosierung WLAN SSID"
      entity_category: diagnostic
    bssid:
      name: "Dosierung WLAN BSSID"
      entity_category: diagnostic
    mac_address:
      name: "Dosierung MAC"
      entity_category: diagnostic
    # Zeigt Netzwerk-Informationen an (IP, SSID, MAC-Adresse)

  - platform: version
    name: "ESPHome Version"
    entity_category: diagnostic

  - platform: template
    name: "Projekt Version"
    entity_category: diagnostic
    lambda: |-
      return {"2.6"};
    update_interval: 60s

  - platform: template
    name: "Dosierung Status Zusammenfassung"
    entity_category: diagnostic
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Micro: %.0f%% | Grow: %.0f%% | Bloom: %.0f%% | pH Down: %.0f%% | RÃ¼hr: %.0f%%",
        id(pump1_speed).state,
        id(pump2_speed).state,
        id(pump3_speed).state,
        id(pump4_speed).state,
        id(stir_speed).state
      );
      return std::string(buffer);
    update_interval: 5s
    # Kompaktes Status-Dashboard: Drehzahlen aller 4 Pumpen + RÃ¼hrmotor

  - platform: template
    name: "Dosierung Pumpen Status"
    entity_category: diagnostic
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Micro: %s | Grow: %s | Bloom: %s | pH Down: %s | RÃ¼hr: %s",
        id(pump1_switch).state ? "AN" : "AUS",
        id(pump2_switch).state ? "AN" : "AUS",
        id(pump3_switch).state ? "AN" : "AUS",
        id(pump4_switch).state ? "AN" : "AUS",
        "AN"
      );
      return std::string(buffer);
    update_interval: 5s
    # Zeigt den Zustand aller 4 Pumpen + RÃ¼hrmotor: AN/AUS

  - platform: template
    name: "Dosierung Reset Grund"
    entity_category: diagnostic
    icon: "mdi:restart-alert"
    lambda: |-
      switch (esp_reset_reason()) {
        case ESP_RST_POWERON: return {"poweron"};
        case ESP_RST_EXT: return {"ext"};
        case ESP_RST_SW: return {"sw"};
        case ESP_RST_PANIC: return {"panic"};
        case ESP_RST_INT_WDT: return {"int_wdt"};
        case ESP_RST_TASK_WDT: return {"task_wdt"};
        case ESP_RST_WDT: return {"wdt"};
        case ESP_RST_DEEPSLEEP: return {"deepsleep"};
        case ESP_RST_BROWNOUT: return {"brownout"};
        case ESP_RST_SDIO: return {"sdio"};
        default: return {"unknown"};
      }

  - platform: template
    name: "Dosierung Aktive Dosierung"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"EC"};
      }
      if (id(dose_ph_correction).is_running()) {
        return {"pH"};
      }
      return {"keine"};
    update_interval: 5s
    # Zeigt, welche Logik gerade lÃ¤uft (EC / pH / keine)

  - platform: template
    name: "Dosierung Zyklus"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"EC"};
      }
      if (id(dose_ph_correction).is_running()) {
        return {"pH"};
      }
      return {"idle"};
    update_interval: 5s
    # Aktueller Dosier-Zyklus (EC / pH / idle)

  - platform: template
    name: "Dosierung NÃ¤chste Menge (ml)"
    entity_category: diagnostic
    lambda: |-
      if (isnan(id(ec_current).state) || isnan(id(ph_current).state)) {
        return {"unavailable"};
      }
      float system_liters = id(system_volume_liters).state;
      if (system_liters <= 0.0f) {
        return {"unavailable"};
      }

      std::string ec_part = "EC: ";
      float ec_ml = 0.0f;
      float ec_diff = id(ec_target).state - id(ec_current).state;
      if (ec_diff >= 0.05f) {
        float ec_per_ml_100L = id(pump_a_ec_per_ml).state;
        float ec_per_ml_actual = ec_per_ml_100L * (100.0f / system_liters);
        if (ec_per_ml_actual > 0.0f) {
          ec_ml = ec_diff / ec_per_ml_actual;
          float max_cycle = id(max_dose_per_cycle).state;
          if (ec_ml > max_cycle) ec_ml = max_cycle;
          if (id(pump_a_total_today) + ec_ml > id(pump_a_max_ml_day).state) {
            ec_part += "block";
          } else {
            char buf[24];
            snprintf(buf, sizeof(buf), "%.1f ml", ec_ml);
            ec_part += buf;
          }
        } else {
          ec_part += "0.0 ml";
        }
      } else {
        ec_part += "0.0 ml";
      }

      std::string ph_part = "pH: ";
      float ph_ml = 0.0f;
      float ph_diff = id(ph_target).state - id(ph_current).state;
      if (ph_diff <= -0.1f) {
        float ph_per_ml_100L = id(ph_down_per_ml).state;
        float ph_per_ml_actual = ph_per_ml_100L * (100.0f / system_liters);
        if (ph_per_ml_actual > 0.0f) {
          ph_ml = (-ph_diff) / ph_per_ml_actual;
          float max_cycle = id(max_dose_per_cycle).state;
          if (ph_ml > max_cycle) ph_ml = max_cycle;
          if (id(pump_d_total_today) + ph_ml > id(pump_d_max_ml_day).state) {
            ph_part += "block";
          } else {
            char buf[24];
            snprintf(buf, sizeof(buf), "%.1f ml", ph_ml);
            ph_part += buf;
          }
        } else {
          ph_part += "0.0 ml";
        }
      } else {
        ph_part += "0.0 ml";
      }

      return ec_part + " | " + ph_part;
    update_interval: 5s
    # Berechnete Zielmenge fÃ¼r den nÃ¤chsten Zyklus (ohne AusfÃ¼hrung)

  - platform: template
    name: "Dosierung Wartezeit (s)"
    entity_category: diagnostic
    lambda: |-
      char buffer[32];
      snprintf(buffer, sizeof(buffer), "%.0f s", id(next_dose_countdown).state);
      return std::string(buffer);
    update_interval: 5s
    # Aktuelle Wartezeit bis zur nÃ¤chsten Dosierung

  - platform: template
    name: "RÃ¼hrzeit Rest (s)"
    entity_category: diagnostic
    lambda: |-
      if (id(last_dose_timestamp) == 0) return {"0 s"};
      float elapsed = (millis() - id(last_dose_timestamp)) / 1000.0f;
      float remaining = id(stir_time).state - elapsed;
      if (remaining < 0) remaining = 0;
      char buffer[32];
      snprintf(buffer, sizeof(buffer), "%.0f s", remaining);
      return std::string(buffer);
    update_interval: 5s
    # Restzeit der RÃ¼hrphase nach letzter Dosierung

  - platform: template
    name: "Dosierung Letzte Menge"
    entity_category: diagnostic
    lambda: |-
      if (id(last_dose_kind) == 0) return {"keine"};
      const char* kind = (id(last_dose_kind) == 1) ? "EC" : "pH";
      float seconds = id(time_since_last_dose).state;
      char buffer[64];
      snprintf(buffer, sizeof(buffer), "%s %.1f ml, vor %.0f s", kind, id(last_dose_ml), seconds);
      return std::string(buffer);
    update_interval: 5s
    # Letzte Dosiermenge inkl. Zeit seit der Dosierung

  - platform: template
    name: "Dosierung Aktive Pumpen"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ph_correction).is_running()) {
        return {"pH Down"};
      }
      if (id(dose_ec_nutrients).is_running()) {
        std::string pumps;
        if (id(pump1_switch).state) pumps += "Micro ";
        if (id(pump2_switch).state) pumps += "Grow ";
        if (id(pump3_switch).state) pumps += "Bloom ";
        if (pumps.empty()) return {"keine"};
        return pumps;
      }
      return {"keine"};
    update_interval: 5s
    # Zeigt die aktiven Pumpen (fÃ¼r EC/pH)

  - platform: template
    name: "Dosierung Schritt"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"dosieren ec"};
      }
      if (id(dose_ph_correction).is_running()) {
        return {"dosieren ph"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"ruehrzeit"};
      }
      return {"bereit"};
    update_interval: 5s
    # Aktueller Prozess-Schritt fÃ¼r das Dashboard

  - platform: template
    name: "Dosierung Letzte Aktion"
    entity_category: diagnostic
    lambda: |-
      if (id(last_dose_kind) == 1) return {"ec dosiert"};
      if (id(last_dose_kind) == 2) return {"ph dosiert"};
      return {"keine"};
    update_interval: 5s
    # Letztes Ergebnis (nur Anzeige)

  - platform: template
    name: "EC Ist (empfangen)"
    entity_category: diagnostic
    lambda: |-
      if (isnan(id(ec_current).state)) return {"unavailable"};
      char buffer[32];
      snprintf(buffer, sizeof(buffer), "%.2f mS/cm", id(ec_current).state);
      return std::string(buffer);
    update_interval: 5s
    # Zeigt den zuletzt empfangenen EC-Istwert (Hydroknoten)

  - platform: template
    name: "pH Ist (empfangen)"
    entity_category: diagnostic
    lambda: |-
      if (isnan(id(ph_current).state)) return {"unavailable"};
      char buffer[32];
      snprintf(buffer, sizeof(buffer), "%.2f pH", id(ph_current).state);
      return std::string(buffer);
    update_interval: 5s
    # Zeigt den zuletzt empfangenen pH-Istwert (Hydroknoten)

  - platform: template
    name: "Debug EC Status"
    entity_category: diagnostic
    lambda: |-
      std::string status = "idle";
      if (id(dose_ec_nutrients).is_running()) {
        status = "dosing";
      } else if (!id(hydroknoten_online).state) {
        status = "blocked: hydroknoten";
      } else if (!id(stir_time_elapsed).state) {
        status = "wait: ruehrzeit";
      } else if (id(pump_a_total_today) >= id(pump_a_max_ml_day).state) {
        status = "blocked: tageslimit micro";
      } else if (id(pump_b_total_today) >= id(pump_b_max_ml_day).state) {
        status = "blocked: tageslimit grow";
      } else if (id(pump_c_total_today) >= id(pump_c_max_ml_day).state) {
        status = "blocked: tageslimit bloom";
      }

      std::string active_pumps;
      if (id(pump1_switch).state) active_pumps += "Micro ";
      if (id(pump2_switch).state) active_pumps += "Grow ";
      if (id(pump3_switch).state) active_pumps += "Bloom ";
      if (active_pumps.empty()) active_pumps = "keine";

      std::string current_pump = "keine";
      if (id(run_pump).is_running() && id(run_pump_kind) == 1) {
        if (id(run_pump_id) == 1) current_pump = "Micro";
        else if (id(run_pump_id) == 2) current_pump = "Grow";
        else if (id(run_pump_id) == 3) current_pump = "Bloom";
      }

      char buffer[256];
      float wait_s = isnan(id(next_dose_countdown).state) ? 0.0f : id(next_dose_countdown).state;
      snprintf(buffer, sizeof(buffer),
        "EC: %s | Warte: %.0f s | Aktuell: %s | Aktiv: %s",
        status.c_str(), wait_s, current_pump.c_str(), active_pumps.c_str()
      );
      return std::string(buffer);
    update_interval: 5s

  - platform: template
    name: "Debug pH Status"
    entity_category: diagnostic
    lambda: |-
      std::string status = "idle";
      if (id(dose_ph_correction).is_running()) {
        status = "dosing";
      } else if (!id(hydroknoten_online).state) {
        status = "blocked: hydroknoten";
      } else if (!id(stir_time_elapsed).state) {
        status = "wait: ruehrzeit";
      } else if (id(pump_d_total_today) >= id(pump_d_max_ml_day).state) {
        status = "blocked: tageslimit ph down";
      }

      std::string current_pump = "keine";
      if (id(run_pump).is_running() && id(run_pump_kind) == 2) {
        current_pump = "pH Down";
      }

      char buffer[256];
      float wait_s = isnan(id(next_dose_countdown).state) ? 0.0f : id(next_dose_countdown).state;
      snprintf(buffer, sizeof(buffer),
        "pH: %s | Warte: %.0f s | Aktuell: %s",
        status.c_str(), wait_s, current_pump.c_str()
      );
      return std::string(buffer);
    update_interval: 5s

  - platform: template
    name: "Debug Dosierung Gesamtstatus"
    entity_category: diagnostic
    lambda: |-
      std::string mode = "idle";
      if (id(dose_ec_nutrients).is_running()) mode = "EC";
      else if (id(dose_ph_correction).is_running()) mode = "pH";

      std::string hydro = id(hydroknoten_online).state ? "online" : "offline";
      std::string stir = id(stir_time_elapsed).state ? "ok" : "wait";
      float wait_s = isnan(id(next_dose_countdown).state) ? 0.0f : id(next_dose_countdown).state;
      float last_s = isnan(id(time_since_last_dose).state) ? 0.0f : id(time_since_last_dose).state;

      const char* last_kind = "keine";
      if (id(last_dose_kind) == 1) last_kind = "EC";
      else if (id(last_dose_kind) == 2) last_kind = "pH";

      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Modus: %s | Hydro: %s | Ruehr: %s | Warte: %.0f s | Letzte: %s vor %.0f s",
        mode.c_str(), hydro.c_str(), stir.c_str(), wait_s, last_kind, last_s
      );
      return std::string(buffer);
    update_interval: 5s

  - platform: template
    name: "Dosierung Status"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"blocked: hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"blocked: rÃ¼hrzeit"};
      }
      if (id(pump_a_total_today) >= id(pump_a_max_ml_day).state) {
        return {"blocked: tageslimit micro"};
      }
      if (id(pump_b_total_today) >= id(pump_b_max_ml_day).state) {
        return {"blocked: tageslimit grow"};
      }
      if (id(pump_c_total_today) >= id(pump_c_max_ml_day).state) {
        return {"blocked: tageslimit bloom"};
      }
      return {"idle"};
    update_interval: 5s
    # EC-Status (Pumpe 1-3)

  - platform: template
    name: "Dosierung Blockgrund"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"rÃ¼hrzeit abwarten"};
      }
      if (id(pump_a_total_today) >= id(pump_a_max_ml_day).state) {
        return {"tageslimit micro"};
      }
      if (id(pump_b_total_today) >= id(pump_b_max_ml_day).state) {
        return {"tageslimit grow"};
      }
      if (id(pump_c_total_today) >= id(pump_c_max_ml_day).state) {
        return {"tageslimit bloom"};
      }
      return {"ok"};
    update_interval: 5s

  - platform: template
    name: "pH Dosierung Status"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ph_correction).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"blocked: hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"blocked: rÃ¼hrzeit"};
      }
      if (id(pump_d_total_today) >= id(pump_d_max_ml_day).state) {
        return {"blocked: tageslimit ph down"};
      }
      return {"idle"};
    update_interval: 5s
    # pH-Status (Pumpe 4)

  - platform: template
    name: "pH Dosierung Blockgrund"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ph_correction).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"rÃ¼hrzeit abwarten"};
      }
      if (id(pump_d_total_today) >= id(pump_d_max_ml_day).state) {
        return {"tageslimit ph down"};
      }
      return {"ok"};
    update_interval: 5s
    # Klarer Blockgrund fÃ¼r HA-Dashboard

# ===============================================================
# BINARY SENSOREN (HEALTH CHECKS, SAFETY ALARMS)
# ===============================================================

binary_sensor:
  - platform: status
    name: "Status verbunden"
    device_class: connectivity
    entity_category: diagnostic

  # RÃ¼hrzeit Check (TRUE = Dosierung erlaubt)
  - platform: template
    name: "RÃ¼hrzeit abgelaufen"
    id: stir_time_elapsed
    entity_category: diagnostic
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      return time_passed >= min_wait;

  # Hydroknoten Online Check
  - platform: template
    name: "Hydroknoten Online"
    id: hydroknoten_online
    device_class: connectivity
    entity_category: diagnostic
    lambda: |-
      // Check ob EC-Wert aktualisiert wird (nicht NaN)
      return !isnan(id(ec_current).state) && !isnan(id(ph_current).state);

  # Safety Limits (90% Warnung)
  - platform: template
    name: "Micro â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_a_total_today) >= (id(pump_a_max_ml_day).state * 0.9);

  - platform: template
    name: "Grow â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_b_total_today) >= (id(pump_b_max_ml_day).state * 0.9);

  - platform: template
    name: "Bloom â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_c_total_today) >= (id(pump_c_max_ml_day).state * 0.9);

  - platform: template
    name: "pH Down â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_d_total_today) >= (id(pump_d_max_ml_day).state * 0.9);

  # Tageslimit erreicht (harte Grenze)
  - platform: template
    name: "Micro â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_a_total_today) >= id(pump_a_max_ml_day).state;

  - platform: template
    name: "Grow â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_b_total_today) >= id(pump_b_max_ml_day).state;

  - platform: template
    name: "Bloom â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_c_total_today) >= id(pump_c_max_ml_day).state;

  - platform: template
    name: "pH Down â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_d_total_today) >= id(pump_d_max_ml_day).state;

  # Irgendeine Pumpe aktiv?
  - platform: template
    name: "Dosierung aktiv"
    lambda: |-
        return id(pump1_switch).state || id(pump2_switch).state || 
               id(pump3_switch).state || id(pump4_switch).state;

# ===============================================================
# BUTTONS (RESTART, DAILY RESET)
# ===============================================================
button:
  - platform: restart
    name: "Dosierung â€“ Restart"

  - platform: safe_mode
    name: "Dosierung â€“ Safe Mode"

  - platform: template
    name: "Reset Tages-Counter"
    on_press:
      - logger.log: "ğŸ”„ Tages-Counter zurÃ¼ckgesetzt"
      - lambda: |-
          id(pump_a_total_today) = 0.0;
          id(pump_b_total_today) = 0.0;
          id(pump_c_total_today) = 0.0;
          id(pump_d_total_today) = 0.0;

  - platform: template
    name: "Reset Lifetime-Counter"
    on_press:
      - logger.log: "ğŸ”„ Lifetime-Counter zurÃ¼ckgesetzt"
      - lambda: |-
          id(pump_a_lifetime_ml) = 0.0;
          id(pump_b_lifetime_ml) = 0.0;
          id(pump_c_lifetime_ml) = 0.0;
          id(pump_d_lifetime_ml) = 0.0;
          id(pump_a_cycles) = 0;
          id(pump_b_cycles) = 0;
          id(pump_c_cycles) = 0;
          id(pump_d_cycles) = 0;

  - platform: template
    name: "Reset Dosierzyklen"
    on_press:
      - logger.log: "ğŸ”„ Dosierzyklen zurÃ¼ckgesetzt"
      - lambda: |-
          id(pump_a_cycles) = 0;
          id(pump_b_cycles) = 0;
          id(pump_c_cycles) = 0;
          id(pump_d_cycles) = 0;


# ===============================================================
# SCRIPTS (DOSIER-LOGIK, DAILY RESET)
# ===============================================================
script:
    - id: daily_reset_script
      mode: single
      then:
        - logger.log: "ğŸŒ… Mitternacht â€“ Tages-Counter Reset"
        - lambda: |-
            id(pump_a_total_today) = 0.0;
            id(pump_b_total_today) = 0.0;
            id(pump_c_total_today) = 0.0;
            id(pump_d_total_today) = 0.0;

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PUMPENLAUF (NICHT BLOCKIEREND)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: run_pump
      mode: queued
      then:
        - lambda: |-
            int p = id(run_pump_id);
            if (p == 1) id(pump1_output).set_level(1.0f);
            else if (p == 2) id(pump2_output).set_level(1.0f);
            else if (p == 3) id(pump3_output).set_level(1.0f);
            else if (p == 4) id(pump4_output).set_level(1.0f);
        - delay: !lambda 'return (uint32_t)(id(run_pump_seconds) * 1000);'
        - lambda: |-
            int p = id(run_pump_id);
            if (p == 1) id(pump1_output).set_level(0.0f);
            else if (p == 2) id(pump2_output).set_level(0.0f);
            else if (p == 3) id(pump3_output).set_level(0.0f);
            else if (p == 4) id(pump4_output).set_level(0.0f);

            float ml = id(run_pump_ml);
            if (p == 1) { id(pump_a_total_today) += ml; id(pump_a_lifetime_ml) += ml; id(pump_a_cycles) += 1; }
            else if (p == 2) { id(pump_b_total_today) += ml; id(pump_b_lifetime_ml) += ml; id(pump_b_cycles) += 1; }
            else if (p == 3) { id(pump_c_total_today) += ml; id(pump_c_lifetime_ml) += ml; id(pump_c_cycles) += 1; }
            else if (p == 4) { id(pump_d_total_today) += ml; id(pump_d_lifetime_ml) += ml; id(pump_d_cycles) += 1; }

            id(last_dose_ml) = ml;
            id(last_dose_kind) = id(run_pump_kind);
            id(last_dose_timestamp) = millis();

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE EC-DOSIERUNG (Pumpe A)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ec_nutrients
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ EC-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ec_nutrients

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ EC-Dosierung abgebrochen"
              - script.stop: dose_ec_nutrients

        # STEP 3: EC-Berechnung (nicht blockierend)
        - lambda: |-
            id(ec_should_stop) = 0;
            float ec_diff = id(ec_target).state - id(ec_current).state;
            if (ec_diff < 0.05f) {
              ESP_LOGI("dose_ec", "âœ“ EC bereits im Zielbereich (%.2f mS/cm)", id(ec_current).state);
              id(ec_should_stop) = 1;
              return;
            }
            int active_pumps = 0;
            if (id(pump1_switch).state) active_pumps++;
            if (id(pump2_switch).state) active_pumps++;
            if (id(pump3_switch).state) active_pumps++;
            if (active_pumps == 0) {
              ESP_LOGW("dose_ec", "âš ï¸ Keine EC-Pumpe aktiv");
              id(ec_should_stop) = 1;
              return;
            }
            id(ec_active_pumps) = active_pumps;
            id(ec_share) = ec_diff / (float)active_pumps;
        - if:
            condition:
              lambda: 'return id(ec_should_stop) == 1;'
            then:
              - script.stop: dose_ec_nutrients

        - if:
            condition:
              lambda: 'return id(ec_should_stop) == 0 && id(pump1_switch).state;'
            then:
              - lambda: |-
                  id(run_valid) = 0;
                  float system_liters = id(system_volume_liters).state;
                  float ec_per_ml_100L = id(pump_a_ec_per_ml).state;
                  float ec_per_ml_actual = ec_per_ml_100L * (100.0f / system_liters);
                  if (ec_per_ml_actual <= 0.0f) {
                    ESP_LOGW("dose_ec", "âš ï¸ Micro EC-Wirksamkeit = 0");
                    return;
                  }
                  float ml_needed = id(ec_share) / ec_per_ml_actual;
                  float max_cycle = id(max_dose_per_cycle).state;
                  if (ml_needed > max_cycle) ml_needed = max_cycle;
                  if (id(pump_a_total_today) + ml_needed > id(pump_a_max_ml_day).state) {
                    ESP_LOGE("dose_ec", "âŒ Tageslimit Micro erreicht!");
                    return;
                  }
                  id(run_pump_id) = 1;
                  id(run_pump_kind) = 1;
                  id(run_pump_ml) = ml_needed;
                  id(run_pump_seconds) = ml_needed / id(pump_a_flow_ml_per_sec).state;
                  id(run_valid) = 1;
              - if:
                  condition:
                    lambda: 'return id(run_valid) == 1;'
                  then:
                    - logger.log: "ğŸ’§ Micro Dosierung lÃ¤uft"
                    - script.execute: run_pump
                    - wait_until:
                        condition:
                          not:
                            script.is_running: run_pump
                    - logger.log:
                        format: "â³ RÃ¼hrzeit lÃ¤uft: %.0f s"
                        args: ['id(stir_time).state']
                    - delay: !lambda 'return (uint32_t)(id(stir_time).state * 1000);'
                    - lambda: |-
                        float ec_diff = id(ec_target).state - id(ec_current).state;
                        if (ec_diff < 0.05f) {
                          ESP_LOGI("dose_ec", "âœ“ EC erreicht nach RÃ¼hrzeit (%.2f mS/cm)", id(ec_current).state);
                          id(ec_should_stop) = 1;
                        } else {
                          id(ec_share) = ec_diff / (float)id(ec_active_pumps);
                        }

        - if:
            condition:
              lambda: 'return id(ec_should_stop) == 0 && id(pump2_switch).state;'
            then:
              - lambda: |-
                  id(run_valid) = 0;
                  float system_liters = id(system_volume_liters).state;
                  float ec_per_ml_100L = id(pump_b_ec_per_ml).state;
                  float ec_per_ml_actual = ec_per_ml_100L * (100.0f / system_liters);
                  if (ec_per_ml_actual <= 0.0f) {
                    ESP_LOGW("dose_ec", "âš ï¸ Grow EC-Wirksamkeit = 0");
                    return;
                  }
                  float ml_needed = id(ec_share) / ec_per_ml_actual;
                  float max_cycle = id(max_dose_per_cycle).state;
                  if (ml_needed > max_cycle) ml_needed = max_cycle;
                  if (id(pump_b_total_today) + ml_needed > id(pump_b_max_ml_day).state) {
                    ESP_LOGE("dose_ec", "âŒ Tageslimit Grow erreicht!");
                    return;
                  }
                  id(run_pump_id) = 2;
                  id(run_pump_kind) = 1;
                  id(run_pump_ml) = ml_needed;
                  id(run_pump_seconds) = ml_needed / id(pump_b_flow_ml_per_sec).state;
                  id(run_valid) = 1;
              - if:
                  condition:
                    lambda: 'return id(run_valid) == 1;'
                  then:
                    - logger.log: "ğŸ’§ Grow Dosierung lÃ¤uft"
                    - script.execute: run_pump
                    - wait_until:
                        condition:
                          not:
                            script.is_running: run_pump
                    - logger.log:
                        format: "â³ RÃ¼hrzeit lÃ¤uft: %.0f s"
                        args: ['id(stir_time).state']
                    - delay: !lambda 'return (uint32_t)(id(stir_time).state * 1000);'
                    - lambda: |-
                        float ec_diff = id(ec_target).state - id(ec_current).state;
                        if (ec_diff < 0.05f) {
                          ESP_LOGI("dose_ec", "âœ“ EC erreicht nach RÃ¼hrzeit (%.2f mS/cm)", id(ec_current).state);
                          id(ec_should_stop) = 1;
                        } else {
                          id(ec_share) = ec_diff / (float)id(ec_active_pumps);
                        }

        - if:
            condition:
              lambda: 'return id(ec_should_stop) == 0 && id(pump3_switch).state;'
            then:
              - lambda: |-
                  id(run_valid) = 0;
                  float system_liters = id(system_volume_liters).state;
                  float ec_per_ml_100L = id(pump_c_ec_per_ml).state;
                  float ec_per_ml_actual = ec_per_ml_100L * (100.0f / system_liters);
                  if (ec_per_ml_actual <= 0.0f) {
                    ESP_LOGW("dose_ec", "âš ï¸ Bloom EC-Wirksamkeit = 0");
                    return;
                  }
                  float ml_needed = id(ec_share) / ec_per_ml_actual;
                  float max_cycle = id(max_dose_per_cycle).state;
                  if (ml_needed > max_cycle) ml_needed = max_cycle;
                  if (id(pump_c_total_today) + ml_needed > id(pump_c_max_ml_day).state) {
                    ESP_LOGE("dose_ec", "âŒ Tageslimit Bloom erreicht!");
                    return;
                  }
                  id(run_pump_id) = 3;
                  id(run_pump_kind) = 1;
                  id(run_pump_ml) = ml_needed;
                  id(run_pump_seconds) = ml_needed / id(pump_c_flow_ml_per_sec).state;
                  id(run_valid) = 1;
              - if:
                  condition:
                    lambda: 'return id(run_valid) == 1;'
                  then:
                    - logger.log: "ğŸ’§ Bloom Dosierung lÃ¤uft"
                    - script.execute: run_pump
                    - wait_until:
                        condition:
                          not:
                            script.is_running: run_pump
                    - logger.log:
                        format: "â³ RÃ¼hrzeit lÃ¤uft: %.0f s"
                        args: ['id(stir_time).state']
                    - delay: !lambda 'return (uint32_t)(id(stir_time).state * 1000);'

        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - logger.log: "âœ“ EC-Dosierung + RÃ¼hrvorgang abgeschlossen"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE pH-DOSIERUNG (Pumpe B/C)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ph_correction
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ pH-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ph_correction

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ pH-Dosierung abgebrochen"
              - script.stop: dose_ph_correction

        # STEP 3: pH-Berechnung (nur pH Down Ã¼ber Pumpe D, nicht blockierend)
        - lambda: |-
            id(run_valid) = 0;
            float ph_diff = id(ph_target).state - id(ph_current).state;

            if (abs(ph_diff) < 0.1f) {
              ESP_LOGI("dose_ph", "âœ“ pH bereits im Zielbereich (%.2f)", id(ph_current).state);
              return;
            }

            if (ph_diff > 0.1f) {
              ESP_LOGW("dose_ph", "âš ï¸ pH zu niedrig â€“ pH Up nicht vorhanden");
              return;
            }

            float system_liters = id(system_volume_liters).state;
            float ph_per_ml_100L = id(ph_down_per_ml).state;
            float ph_per_ml_actual = ph_per_ml_100L * (100.0f / system_liters);
            if (ph_per_ml_actual <= 0.0f) {
              ESP_LOGW("dose_ph", "âš ï¸ pH Down Wirksamkeit = 0");
              return;
            }
            float ml_needed = abs(ph_diff) / ph_per_ml_actual;
            ESP_LOGI("dose_ph", "ğŸ“‰ pH zu hoch â€“ pH Down benÃ¶tigt");

            float max_cycle = id(max_dose_per_cycle).state;
            if (ml_needed > max_cycle) {
              ESP_LOGW("dose_ph", "âš ï¸ Begrenzt auf %.0f ml (berechnet: %.1f ml)", max_cycle, ml_needed);
              ml_needed = max_cycle;
            }

            if (id(pump_d_total_today) + ml_needed > id(pump_d_max_ml_day).state) {
              ESP_LOGE("dose_ph", "âŒ Tageslimit Pumpe D erreicht!");
              return;
            }

            id(run_pump_id) = 4;
            id(run_pump_kind) = 2;
            id(run_pump_ml) = ml_needed;
            id(run_pump_seconds) = ml_needed / id(pump_d_flow_ml_per_sec).state;
            id(run_valid) = 1;
        - if:
            condition:
              lambda: 'return id(run_valid) == 1;'
            then:
              - logger.log: "ğŸ’§ pH Down Dosierung lÃ¤uft"
              - script.execute: run_pump
              - wait_until:
                  condition:
                    not:
                      script.is_running: run_pump
              - logger.log:
                  format: "â³ RÃ¼hrzeit lÃ¤uft: %.0f s"
                  args: ['id(stir_time).state']
              - delay: !lambda 'return (uint32_t)(id(stir_time).state * 1000);'
        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - logger.log: "âœ“ pH-Dosierung + RÃ¼hrvorgang abgeschlossen"
# ===============================================================
# INTERVAL (DAILY RESET UM 00:00)
# ===============================================================
interval:
  - interval: 1h
    then:
      - lambda: |-
          auto time = id(ha_time).now();
          if (time.hour == 0 && time.minute == 0) {
            id(daily_reset_script).execute();
          }

  - interval: 10s
    then:
      - if:
          condition:
            lambda: |-
              return id(dosierung_automatik).state &&
                     id(stir_time_elapsed).state &&
                     !id(dose_ec_nutrients).is_running() &&
                     !id(dose_ph_correction).is_running();
          then:
            - logger.log: "â–¶ï¸ Automatik: starte EC-Dosierung"
            - script.execute: dose_ec_nutrients
      - if:
          condition:
            lambda: |-
              return id(dosierung_automatik).state &&
                     id(stir_time_elapsed).state &&
                     !id(dose_ec_nutrients).is_running() &&
                     !id(dose_ph_correction).is_running();
          then:
            - logger.log: "â–¶ï¸ Automatik: starte pH-Dosierung"
            - script.execute: dose_ph_correction



################################################################################
# COPILOT-ANWEISUNG â€“ BITTE VOR JEDER CODE-Ã„NDERUNG LESEN
#
# ZIEL
# Dieser ESPHome-Knoten soll ein VOLLSTÃ„NDIG AUTARKER RDWC-DOSIERCONTROLLER sein.
# SÃ¤mtliche Bedienelemente (number, switch, button, sensor) MÃœSSEN
# direkt vom ESP bereitgestellt werden.
#
# Home Assistant dient NUR als:
# - Anzeige (Dashboard)
# - Datenquelle fÃ¼r EC- und pH-Messwerte vom Hydroknoten
#
# ES DÃœRFEN KEINE NEUEN input_number / input_boolean IN HOME ASSISTANT
# VORAUSGESETZT ODER BENÃ–TIGT WERDEN.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GRUNDKONZEPT DER DOSIERUNG
#
# - Es existieren 4 Dosierpumpen (Pumpe Aâ€“D)
# - Jede Pumpe kann einen beliebigen DÃ¼nger eines Herstellers reprÃ¤sentieren
# - Jede Pumpe besitzt:
#   - EC-Wirksamkeit pro ml (EC-ErhÃ¶hung pro ml bei 100 Liter)
#   - FÃ¶rderleistung (ml pro Sekunde)
#   - Tageslimit (ml/Tag)
#   - Maximaldosis pro Zyklus (ml)
#
# - Die EC-Regelung basiert auf einer VERTEILUNGSLOGIK:
#   Die EC-Differenz zwischen Ist- und Sollwert MUSS gleichmÃ¤ÃŸig
#   auf alle AKTIVEN DÃ¼ngerpumpen verteilt werden.
#
#   Beispiele:
#   - 1 aktive Pumpe  â†’ 100 % der EC-Differenz
#   - 2 aktive Pumpen â†’ je 50 %
#   - 3 aktive Pumpen â†’ je 33,33 %
#   - 4 aktive Pumpen â†’ je 25 %
#
# - pH-Pumpen (pH Up / pH Down) sind NICHT Teil der EC-Verteilungslogik
#   und werden ausschlieÃŸlich fÃ¼r pH-Korrekturen verwendet.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ZWANGSVORGABEN FÃœR ENTITÃ„TEN (MÃœSSEN VOM ESP BEREITGESTELLT WERDEN)
#
# FÃœR JEDE PUMPE Aâ€“D:
# - switch:   Aktiv / Inaktiv (Teilnahme an EC-Verteilung)
# - button:   Manuelle Dosierung NUR dieser Pumpe
# - sensor:   Berechnete Dosiermenge (ml)
# - sensor:   Berechnete Laufzeit (Sekunden)
#
# GLOBAL:
# - button:   "Automatische EC-Dosierung starten"
# - sensor:   "Anzahl aktive DÃ¼nger"
# - sensor:   "EC-Differenz (Soll â€“ Ist)"
# - sensor:   "Dosierstatus" (idle / dosing / stirring / blocked)
#
# ALLE ENTITÃ„TEN MÃœSSEN:
# - dashboardfÃ¤hig sein
# - sprechende Namen haben
# - restorefÃ¤hig sein, wo sinnvoll
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# RÃœHRZEIT & DOSIERABLAUF (KRITISCH)
#
# - Dosierungen erfolgen IMMER SEQUENZIELL, niemals parallel
# - Nach JEDER Dosierung MUSS eine RÃ¼hrzeit abgewartet werden
# - Die RÃ¼hrzeit ist als number im ESP konfigurierbar (Sekunden)
# - Ist die RÃ¼hrzeit noch nicht abgelaufen:
#   â†’ Dosierung BLOCKIEREN
#
# Ablauf:
#   Berechnung â†’ Pumpe dosieren â†’ RÃ¼hren â†’ nÃ¤chste Pumpe
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SICHERHEITSLOGIK (DARF NICHT UMGEHEN WERDEN)
#
# - Tageslimits pro Pumpe strikt einhalten
# - Maximaldosis pro Zyklus strikt einhalten
# - Keine Dosierung wenn:
#   - Hydroknoten offline ist
#   - EC/pH-Werte ungÃ¼ltig (NaN) sind
#   - RÃ¼hrzeit noch nicht abgelaufen ist
#
# - Bei Blockierung MUSS:
#   - ein Log-Eintrag erfolgen
#   - der Dosierstatus entsprechend gesetzt werden
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ARCHITEKTUR-REGELN
#
# - KEINE while-Loops
# - KEINE blockierenden delays auÃŸerhalb von ESPHome scripts
# - Dosierlogik ausschlieÃŸlich Ã¼ber scripts + delay
# - Alle Berechnungen erfolgen lokal im ESP
#
# - Bestehende Logik darf NICHT entfernt werden
# - Erweiterungen mÃ¼ssen rÃ¼ckwÃ¤rtskompatibel sein
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DENKWEISE FÃœR COPILOT
#
# Der ESP ist die "Single Source of Truth".
# Home Assistant ist nur Anzeige & Fernbedienung.
#
# Wenn du unsicher bist:
# â†’ NICHT vereinfachen
# â†’ NICHT entfernen
# â†’ bestehende Sicherheitslogik priorisieren
################################################################################
