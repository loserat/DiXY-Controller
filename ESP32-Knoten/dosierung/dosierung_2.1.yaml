################################################################################
# DiXY RDWC Dosierknoten v0.5-beta
#
# WHAT IT DOES
# - 4 Peristaltik-Pumpen fÃ¼r EC/pH Auto-Dosierung steuern
# - Berechnet aus echten Hydroknoten-Daten wie viel ml nÃ¶tig ist
# - Checkt: ist genug Zeit vergangen? Ist Hydroknoten online?
# - Respektiert Safety Limits (pro Tag, pro Zyklus)
# - RÃ¼hrmotor lÃ¤uft nach jeder Dosierung (Durchmischung)
#
# CRITICAL DEPENDENCIES
# - EC & pH Sensordaten vom Hydroknoten (via HA API)
# - System-Volumen muss in HA als input_number gesetzt sein
# - HA braucht Time-Service fÃ¼r tÃ¤gliche Counter-Resets
# FALLBACK: Ohne Hydroknoten geht gar nix (Dosierung blockiert)
#
# OPTIONAL DEPENDENCIES
# - HA fÃ¼r Logging (lokal mit Safety Limits funktioniert offline)
# - Buzzer auf GPIO27 (v0.6 geplant)
#
# HARDWARE
# - ESP32-DevKit + 4x Peristaltik-Pumpen + MCP4131 Potentiometer
# - SPI Bus fÃ¼r RÃ¼hrmotor & Inline-Fan PWM
# - PWM: GPIO12-15 fÃ¼r 4 Pumpen
#
# FEATURES v0.5
# - Health Monitoring V2 (Boot-Graceperiod 300s, Failure Counter)
# - EC/pH-Regelung mit Wirksamkeits-Berechnung
# - RÃ¼hrzeit-Management (min. 3min zwischen Dosierungen)
# - Safety Limits + Flow-Rate Kalibrierung
# - Lifetime Statistics (Total ml, Runtime, Zyklen)
# - WiFi Diagnostics + Reset Grund Detection
#
# SUBSTITUTION (easy hardware swapping)
# - Alle GPIO + I2C Adressen substituierbar
# - Kein hardcoding â†’ v1.0 Single-PCB Integration vorbereitet
#
# FUTURE (v1.0)
# - EC/pH kÃ¶nnten direkt vom lokalen ADS1115 kommen (statt HA)
# - Buzzer-Output einfach ergÃ¤nzbar
# - GPIO Pins leicht auf andere PCB-Pins ummappbar
################################################################################

substitutions:
  device_name: dosierung
  friendly_name: "Dosierung"
  device_description: "Intelligente Auto-Dosierung + Safety"
  project_version: "0.1"
  
  # SPI Pins
  spi_clk_pin: "2"
  spi_mosi_pin: "3"
  # mcp4131_fan_cs_pin: "1"
  # mcp4131_stir_cs_pin: "4"
  
  # Pumpen GPIO Pins
  pump_a_pin: "12"  # EC HauptdÃ¼nger
  pump_b_pin: "13"  # DÃ¼nger 2 (EC)
  pump_c_pin: "14"  # DÃ¼nger 3 (EC)
  pump_d_pin: "15"  # pH Down
  
  # Timing Defaults
  min_stir_time: "180"        # 3min Pflicht-RÃ¼hrzeit zwischen Dosierungen
  full_mix_time: "300"         # 5min fÃ¼r komplette RDWC-Durchmischung
  stir_duration: "90"          # 90s Standard RÃ¼hrmotor-Lauf
  
  # Safety Limits
  max_dose_per_cycle: "50"     # Max 50ml pro Dosierung
  max_ml_per_day: "200"        # Max 200ml/Tag pro Pumpe

esphome:
  name: dosierung
  friendly_name: Dosierung
  comment: "DiXY Dosierknoten v0.2-beta â€“ Intelligente EC/pH-Regelung + RÃ¼hrzeit-Management + Safety Limits"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# ===============================================================
# SPI BUS (fÃ¼r MCP4131 Digitale Potentiometer)
# ===============================================================
# MCP4131 steuert PWM fÃ¼r Inline-Fan und RÃ¼hrmotor
# via digitale Potentiometer (0-255 Werte = 0-100%)
# ===============================================================
spi:
  id: spi_mcp
  clk_pin: ${spi_clk_pin}
  mosi_pin: ${spi_mosi_pin}
  # MISO wird nicht benÃ¶tigt fÃ¼r MCP4131 Write-Only

# ===============================================================
# LOGGING
# ===============================================================
logger:
  level: INFO
  baud_rate: 115200

# ===============================================================
# NETZWERK & AUTHENTIFIZIERUNG
# ===============================================================
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret dosierung_ap_ssid
    password: !secret dosierung_ap_password

api:
  reboot_timeout: 0s

ota:
  platform: esphome
  password: !secret dosierung_ota_password

web_server:
  port: 80

time:
  - platform: homeassistant
    id: ha_time

# ===============================================================
# GLOBALS â€“ RÃœHRZEIT & COUNTER MANAGEMENT
# ===============================================================
globals:
  # Timestamp der letzten Dosierung (fÃ¼r RÃ¼hrzeit-Check)
  - id: last_dose_timestamp
    type: unsigned long
    initial_value: '0'
    # Unix ms seit letzter Dosierung

  # Tages-Counter (Reset um Mitternacht)
  - id: pump_a_total_today
    type: float
    initial_value: '0.0'

  - id: pump_b_total_today
    type: float
    initial_value: '0.0'

  - id: pump_c_total_today
    type: float
    initial_value: '0.0'

  - id: pump_d_total_today
    type: float
    initial_value: '0.0'

  # Lifetime Counter (persistent Ã¼ber Reboots)
  - id: pump_a_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_b_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_c_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  - id: pump_d_lifetime_ml
    type: float
    initial_value: '0.0'
    restore_value: yes

  # Dosier-Zyklen Counter
  - id: pump_a_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_b_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_c_cycles
    type: int
    initial_value: '0'
    restore_value: yes

  - id: pump_d_cycles
    type: int
    initial_value: '0'
    restore_value: yes

# ===============================================================
# SENSOREN: EC-Wert vom Hydroknoten (Home Assistant Integration)
# ===============================================================
# EC-Sensorwert wird vom Hydroknoten gemessen und Ã¼ber
# Home Assistant API in Echtzeit verfÃ¼gbar gemacht
# ===============================================================

sensor:
  # EC vom Hydroknoten abrufen
  - platform: homeassistant
    name: "EC Aktuell (von Hydroknoten)"
    id: ec_current
    entity_id: sensor.hydroknoten_ec_sensor
    accuracy_decimals: 2

  # pH vom Hydroknoten abrufen
  - platform: homeassistant
    name: "pH Aktuell (von Hydroknoten)"
    id: ph_current
    entity_id: sensor.hydroknoten_ph_sensor
    accuracy_decimals: 2
    
  # pH-Zielwert (von HA Input-Helper gesetzt)
  - platform: homeassistant
    name: "pH Zielwert"
    id: ph_target
    entity_id: input_number.ph_target
    accuracy_decimals: 2

  # System-Volumen (von HA oder Hydroknoten)
  - platform: homeassistant
    name: "System Volumen Gesamt"
    id: system_volume_liters
    entity_id: input_number.rdwc_liter
    unit_of_measurement: "L"
    accuracy_decimals: 1
    # Fallback: Manuell in HA setzen (z.B. 80L)

  # --- SYSTEM-SENSOREN (echte ESP32 Hardware) ---
  - platform: wifi_signal
    id: dosier_wifi_signal
    name: "Dosierung WiFi Signal"
    unit_of_measurement: "dBm"
    state_class: measurement
    update_interval: 30s
    entity_category: diagnostic
    # Zeigt WLAN-SignalstÃ¤rke: -30 (sehr gut) bis -100 (sehr schwach)

  - platform: uptime
    name: "Dosierung Uptime"
    unit_of_measurement: "h"
    state_class: total_increasing
    update_interval: 60s
    entity_category: diagnostic
    # Zeigt wie lange der ESP32 lÃ¤uft (in Stunden)

  - platform: internal_temperature
    name: "Dosierung ESP32 Temperatur"
    unit_of_measurement: "Â°C"
    state_class: measurement
    update_interval: 30s
    entity_category: diagnostic
    # Interne Temperatur des Mikrocontrollers (25-90Â°C normalerweise)

  - platform: template
    name: "Dosierung Freier RAM"
    unit_of_measurement: "kB"
    state_class: measurement
    lambda: |-
      // Gibt verfÃ¼gbaren Speicher in Kilobytes aus
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0;
    update_interval: 60s
    entity_category: diagnostic
    # Ãœberwachung: unter 50 kB ist kritisch

  - platform: template
    name: "Dosierung Free Heap"
    unit_of_measurement: "kB"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: 'return (float)esp_get_free_heap_size() / 1024.0f;'
    entity_category: diagnostic
    # Alternative Free Heap Messung (kompatibel mit anderen Knoten)

  # --- PUMPEN-ZUSTAND SENSOREN ---
  # â•â•â• RÃœHRZEIT-TRACKING â•â•â•
  
  - platform: template
    name: "Zeit seit letzter Dosierung"
    id: time_since_last_dose
    unit_of_measurement: "s"
    state_class: measurement
    entity_category: diagnostic
    lambda: |-
      if (id(last_dose_timestamp) == 0) return 999999;  // Noch nie dosiert
      return (millis() - id(last_dose_timestamp)) / 1000.0;
    update_interval: 10s
  
  - platform: template
    name: "NÃ¤chste Dosierung in"
    id: next_dose_countdown
    unit_of_measurement: "s"
    entity_category: diagnostic
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      float remaining = min_wait - time_passed;
      if (remaining < 0) return 0;
      return remaining;
    update_interval: 5s
  
  - platform: template
    name: "Durchmischung Fortschritt"
    id: mix_progress
    unit_of_measurement: "%"
    entity_category: diagnostic
    lambda: |-
      float full_mix = id(full_system_mix_time).state;
      float time_passed = id(time_since_last_dose).state;
      float progress = (time_passed / full_mix) * 100.0;
      if (progress > 100) return 100;
      return progress;
    update_interval: 10s
  
  # â•â•â• TAGES-COUNTER (ml heute dosiert) â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ ml heute"
    id: pump_a_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_a_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe B â€“ ml heute"
    id: pump_b_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_b_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe C â€“ ml heute"
    id: pump_c_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_c_total_today);'
    update_interval: 10s
  
  - platform: template
    name: "Pumpe D â€“ ml heute"
    id: pump_d_ml_today
    unit_of_measurement: "ml"
    state_class: measurement
    entity_category: diagnostic
    lambda: 'return id(pump_d_total_today);'
    update_interval: 10s
  
  # â•â•â• LIFETIME STATISTICS â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Total Lifetime ml"
    id: pump_a_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_a_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe B â€“ Total Lifetime ml"
    id: pump_b_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_b_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe C â€“ Total Lifetime ml"
    id: pump_c_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_c_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe D â€“ Total Lifetime ml"
    id: pump_d_lifetime_sensor
    unit_of_measurement: "ml"
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_d_lifetime_ml);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe A â€“ Dosier-Zyklen"
    id: pump_a_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_a_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe B â€“ Dosier-Zyklen"
    id: pump_b_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_b_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe C â€“ Dosier-Zyklen"
    id: pump_c_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_c_cycles);'
    update_interval: 60s
  
  - platform: template
    name: "Pumpe D â€“ Dosier-Zyklen"
    id: pump_d_cycles_sensor
    state_class: total_increasing
    entity_category: diagnostic
    lambda: 'return id(pump_d_cycles);'
    update_interval: 60s

# ===============================================================
# INPUTS: EC-REGELUNG PARAMETER
# ===============================================================

number:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZIELWERTE (lokal am ESP bereitgestellt)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "EC Zielwert"
    id: ec_target
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.2
    max_value: 3.0
    step: 0.01
    initial_value: 1.8
    restore_value: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DÃœNGER-WIRKSAMKEIT (EC-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ EC pro ml/100L"
    id: pump_a_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.018
    restore_value: true
    # Flora Gro/Micro/Bloom: ~1.8 mS/cm pro 1ml in 100L
  
  - platform: template
    name: "Pumpe B â€“ EC pro ml/100L"
    id: pump_b_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # DÃ¼nger 2 (EC)
  
  - platform: template
    name: "Pumpe C â€“ EC pro ml/100L"
    id: pump_c_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # DÃ¼nger 3 (EC)
  
  - platform: template
    name: "Pumpe D â€“ EC pro ml/100L"
    id: pump_d_ec_per_ml
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.001
    max_value: 0.1
    step: 0.001
    initial_value: 0.0
    restore_value: true
    # pH Down: Keine EC-Wirksamkeit (nur pH-Korrektur)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # pH-WIRKSAMKEIT (pH-Ã„nderung pro ml bei 100L)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "pH Down â€“ Ã„nderung pro ml/100L"
    id: ph_down_per_ml
    unit_of_measurement: "pH"
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.15
    restore_value: true
    # PhosphorsÃ¤ure 40%: -0.15 pH pro ml/100L (stark!)
  
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FLOW-RATE KALIBRIERUNG (echte ml/s pro Pumpe)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Flow Rate"
    id: pump_a_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.5
    restore_value: true
    # Nach Kalibrierung: 60s pumpen = 150ml â†’ 2.5 ml/s
  
  - platform: template
    name: "Pumpe B â€“ Flow Rate"
    id: pump_b_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "Pumpe C â€“ Flow Rate"
    id: pump_c_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 1.8
    restore_value: true
  
  - platform: template
    name: "Pumpe D â€“ Flow Rate"
    id: pump_d_flow_ml_per_sec
    unit_of_measurement: "ml/s"
    optimistic: true
    min_value: 0.1
    max_value: 10.0
    step: 0.1
    initial_value: 2.0
    restore_value: true
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SAFETY LIMITS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Pumpe A â€“ Max ml/Tag"
    id: pump_a_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
  
  - platform: template
    name: "Pumpe B â€“ Max ml/Tag"
    id: pump_b_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
    # DÃ¼nger 2 (EC)
  
  - platform: template
    name: "Pumpe C â€“ Max ml/Tag"
    id: pump_c_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: 100
    restore_value: true
    # DÃ¼nger 3 (EC)
  
  - platform: template
    name: "Pumpe D â€“ Max ml/Tag"
    id: pump_d_max_ml_day
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 10
    max_value: 500
    step: 10
    initial_value: ${max_ml_per_day}
    restore_value: true
    # pH Down
  
  - platform: template
    name: "Max Dosis pro Zyklus"
    id: max_dose_per_cycle
    unit_of_measurement: "ml"
    optimistic: true
    min_value: 5
    max_value: 100
    step: 5
    initial_value: ${max_dose_per_cycle}
    restore_value: true
    # Schutz: Max 50ml pro Dosierung
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RÃœHRZEIT-MANAGEMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "Min. RÃ¼hrzeit zwischen Dosierungen"
    id: min_stir_time_between_doses
    unit_of_measurement: "s"
    optimistic: true
    min_value: 60
    max_value: 600
    step: 10
    initial_value: ${min_stir_time}
    restore_value: true
    # 3min Pflicht-Durchmischung vor nÃ¤chster Dosierung
  
  - platform: template
    name: "Durchmischungs-Dauer (System-Zyklus)"
    id: full_system_mix_time
    unit_of_measurement: "s"
    optimistic: true
    min_value: 120
    max_value: 900
    step: 30
    initial_value: ${full_mix_time}
    restore_value: true
    # 5min = 1 kompletter RDWC-Umlauf
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # LEGACY PARAMETERS (werden nach v0.2 entfernt)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # EC-Sollwert (0.5-3.0 mS/cm)
  - platform: template
    id: ec_setpoint
    name: "EC Sollwert (mS/cm)"
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.5
    max_value: 3.0
    step: 0.1
    initial_value: 1.2
    restore_value: true
    
  # EC-Toleranzbereich (z.B. Â±0.2 mS/cm)
  - platform: template
    id: ec_tolerance
    name: "EC Toleranzbereich (Â±mS/cm)"
    unit_of_measurement: "mS/cm"
    optimistic: true
    min_value: 0.05
    max_value: 0.5
    step: 0.05
    initial_value: 0.2
    restore_value: true
    
  # Dosiervolumen pro Pumpen-Lauf (ml/min)
  - platform: template
    id: pump_volume_ec
    name: "Dosiervolumen EC-Pumpe (ml/min)"
    unit_of_measurement: "ml/min"
    optimistic: true
    min_value: 0.5
    max_value: 10.0
    step: 0.5
    initial_value: 2.0
    restore_value: true
    # EC/MakronÃ¤hrstoffe Dosierung (z.B. Flora Series)

  - platform: template
    id: pump1_speed
    name: "Pumpe 1 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    # MakronÃ¤hrstoffe Dosierung (z.B. EC-A)

  - platform: template
    id: pump2_speed
    name: "Pumpe 2 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # pH-Up oder pH-Down Dosierung

  - platform: template
    id: pump3_speed
    name: "Pumpe 3 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    # MikronÃ¤hrstoffe Dosierung (z.B. Calmag, Vitamine)

  - platform: template
    id: pump4_speed
    name: "Pumpe 4 â€“ Drehzahl"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # RÃ¼hrmotor Einstellungen
  - platform: template
    id: stir_time
    name: "RÃ¼hrmotor â€“ Dauer (Sekunden)"
    unit_of_measurement: "s"
    optimistic: true
    min_value: 30
    max_value: 300
    step: 10
    initial_value: 90
    restore_value: true
    # Wie lange RÃ¼hrmotor nach Dosierung lÃ¤uft (RDWC Durchmischung)

  - platform: template
    id: stir_speed
    name: "RÃ¼hrmotor â€“ PWM Speed"
    unit_of_measurement: "%"
    optimistic: true
    min_value: 30
    max_value: 100
    step: 5
    initial_value: 60
    restore_value: true
    # PWM fÃ¼r RÃ¼hrmotor: 30-100% (mindestens 30% zum Starten)

# ===============================================================
# GPIO PIN DEFINITIONS FÃœR PWM & SPI
# ===============================================================
# GPIO Pins fÃ¼r PWM (Pulse Width Modulation) der Pumpen
# PWM steuert die Motorgeschwindigkeit (0-255 oder 0-100%)
# Frequency: 1000 Hz = typisch fÃ¼r Motorsteuerung
# MCP4131 via SPI: Inline-Fan (GPIO1 CS) + RÃ¼hrmotor (GPIO4 CS)
# ===============================================================
output:
  # PWM Output fÃ¼r Pumpe 1 (GPIO 12)
  - platform: ledc
    id: pump1_output
    pin: GPIO12
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Ausgangsspannung: 0-3.3V (PWM wird von Motor-Treiber verstÃ¤rkt)

  # PWM Output fÃ¼r Pumpe 2 (GPIO 13)
  - platform: ledc
    id: pump2_output
    pin: GPIO13
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 3 (GPIO 14)
  - platform: ledc
    id: pump3_output
    pin: GPIO14
    frequency: 1000 Hz
    min_power: 0
    max_power: 1

  # PWM Output fÃ¼r Pumpe 4 (GPIO 15)
  - platform: ledc
    id: pump4_output
    pin: GPIO15
    frequency: 1000 Hz
    min_power: 0
    max_power: 1
    # Flexible 4. Pumpe: EC-B, pH, oder Additive

  # ===============================================================
  # MCP4131 DIGITALE POTENTIOMETER (SPI) - DEAKTIVIERT
  # ===============================================================
  # TODO: Aktivieren, sobald die Hardware vorhanden ist.

# ===============================================================
# SCHALTER: PUMPEN-STEUERUNG (mit PWM-Geschwindigkeit)
# ===============================================================
# 4 Template-Switches fÃ¼r die Peristaltikpumpen
# Optimistic: true = schaltet sofort (BestÃ¤tigung wird nicht erwartet)
# Lambda konvertiert 0-100% in PWM-Duty-Cycle (0.0-1.0)
# ===============================================================
switch:
  - platform: template
    id: pump1_switch
    name: "Pumpe 1 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump1_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump1_output).set_level(duty_cycle);
        - logger.log: "Pumpe 1 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump1_output
            level: 0.0
        - logger.log: "Pumpe 1 AUS"

  - platform: template
    id: pump2_switch
    name: "Pumpe 2 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump2_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump2_output).set_level(duty_cycle);
        - logger.log: "Pumpe 2 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump2_output
            level: 0.0
        - logger.log: "Pumpe 2 AUS"

  - platform: template
    id: pump3_switch
    name: "Pumpe 3 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump3_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump3_output).set_level(duty_cycle);
        - logger.log: "Pumpe 3 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump3_output
            level: 0.0
        - logger.log: "Pumpe 3 AUS"

  - platform: template
    id: pump4_switch
    name: "Pumpe 4 â€“ Steuerung"
    optimistic: true
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(pump4_speed).state;
            float duty_cycle = speed_percent / 100.0;
            id(pump4_output).set_level(duty_cycle);
        - logger.log: "Pumpe 4 AN"
    turn_off_action:
      then:
        - output.set_level:
            id: pump4_output
            level: 0.0
        - logger.log: "Pumpe 4 AUS"

  # ===============================================================
  # RÃœHRMOTOR STEUERUNG (MCP4131 PWM)
  # ===============================================================
  # Wird automatisch nach Dosierung gestartet
  # Mischt NÃ¤hrstoffe im RDWC-System durch
  # ===============================================================

  - platform: template
    id: stir_motor_switch
    name: "RÃ¼hrmotor â€“ Steuerung"
    optimistic: true
    internal: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      then:
        - lambda: |-
            float speed_percent = id(stir_speed).state;
            // Min 30% fÃ¼r Motor-Startup
            if (speed_percent < 30.0) speed_percent = 30.0;
            // Max 100%
            if (speed_percent > 100.0) speed_percent = 100.0;
            // MCP4131 deaktiviert (Hardware fehlt).
        - logger.log: "RÃ¼hrmotor AN"
    turn_off_action:
      then:
        - logger.log: "RÃ¼hrmotor AUS blockiert (immer aktiv)"
        - switch.turn_on: stir_motor_switch

# ===============================================================
# TEXT SENSOREN (WLAN-INFOS, VERSION, ZUSAMMENFASSUNGEN)
# ===============================================================
# Diese Sensoren zeigen Netzwerk-Infos und Status-Summaries
# NÃ¼tzlich fÃ¼r Dashboards und Debugging
# ===============================================================
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Dosierung IP"
      entity_category: diagnostic
    ssid:
      name: "Dosierung WLAN SSID"
      entity_category: diagnostic
    bssid:
      name: "Dosierung WLAN BSSID"
      entity_category: diagnostic
    mac_address:
      name: "Dosierung MAC"
      entity_category: diagnostic
    # Zeigt Netzwerk-Informationen an (IP, SSID, MAC-Adresse)

  - platform: version
    name: "ESPHome Version"
    entity_category: diagnostic

  - platform: template
    name: "Projekt Version"
    entity_category: diagnostic
    lambda: |-
      return {"v2"};
    update_interval: 60s

  - platform: template
    name: "Dosierung Status Zusammenfassung"
    entity_category: diagnostic
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Pumpe1: %.0f%% | Pumpe2: %.0f%% | Pumpe3: %.0f%% | Pumpe4: %.0f%% | RÃ¼hr: %.0f%%",
        id(pump1_speed).state,
        id(pump2_speed).state,
        id(pump3_speed).state,
        id(pump4_speed).state,
        id(stir_speed).state
      );
      return std::string(buffer);
    update_interval: 5s
    # Kompaktes Status-Dashboard: Drehzahlen aller 4 Pumpen + RÃ¼hrmotor

  - platform: template
    name: "Dosierung Pumpen Status"
    entity_category: diagnostic
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "Pumpe 1: %s | Pumpe 2: %s | Pumpe 3: %s | Pumpe 4: %s | RÃ¼hr: %s",
        id(pump1_switch).state ? "AN" : "AUS",
        id(pump2_switch).state ? "AN" : "AUS",
        id(pump3_switch).state ? "AN" : "AUS",
        id(pump4_switch).state ? "AN" : "AUS",
        "AN"
      );
      return std::string(buffer);
    update_interval: 5s
    # Zeigt den Zustand aller 4 Pumpen + RÃ¼hrmotor: AN/AUS

  - platform: template
    name: "Dosierung Reset Grund"
    entity_category: diagnostic
    icon: "mdi:restart-alert"
    lambda: |-
      switch (esp_reset_reason()) {
        case ESP_RST_POWERON: return {"poweron"};
        case ESP_RST_EXT: return {"ext"};
        case ESP_RST_SW: return {"sw"};
        case ESP_RST_PANIC: return {"panic"};
        case ESP_RST_INT_WDT: return {"int_wdt"};
        case ESP_RST_TASK_WDT: return {"task_wdt"};
        case ESP_RST_WDT: return {"wdt"};
        case ESP_RST_DEEPSLEEP: return {"deepsleep"};
        case ESP_RST_BROWNOUT: return {"brownout"};
        case ESP_RST_SDIO: return {"sdio"};
        default: return {"unknown"};
      }

  - platform: template
    name: "Dosierung Aktive Dosierung"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"EC"};
      }
      if (id(dose_ph_correction).is_running()) {
        return {"pH"};
      }
      return {"keine"};
    update_interval: 5s
    # Zeigt, welche Logik gerade lÃ¤uft (EC / pH / keine)

  - platform: template
    name: "Dosierung Status"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"blocked: hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"blocked: rÃ¼hrzeit"};
      }
      if (id(pump_a_total_today) >= id(pump_a_max_ml_day).state) {
        return {"blocked: tageslimit pumpe a"};
      }
      if (id(pump_b_total_today) >= id(pump_b_max_ml_day).state) {
        return {"blocked: tageslimit pumpe b"};
      }
      if (id(pump_c_total_today) >= id(pump_c_max_ml_day).state) {
        return {"blocked: tageslimit pumpe c"};
      }
      return {"idle"};
    update_interval: 5s
    # EC-Status (Pumpe 1-3)

  - platform: template
    name: "Dosierung Blockgrund"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ec_nutrients).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"rÃ¼hrzeit abwarten"};
      }
      if (id(pump_a_total_today) >= id(pump_a_max_ml_day).state) {
        return {"tageslimit pumpe a"};
      }
      if (id(pump_b_total_today) >= id(pump_b_max_ml_day).state) {
        return {"tageslimit pumpe b"};
      }
      if (id(pump_c_total_today) >= id(pump_c_max_ml_day).state) {
        return {"tageslimit pumpe c"};
      }
      return {"ok"};
    update_interval: 5s

  - platform: template
    name: "pH Dosierung Status"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ph_correction).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"blocked: hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"blocked: rÃ¼hrzeit"};
      }
      if (id(pump_d_total_today) >= id(pump_d_max_ml_day).state) {
        return {"blocked: tageslimit pumpe d"};
      }
      return {"idle"};
    update_interval: 5s
    # pH-Status (Pumpe 4)

  - platform: template
    name: "pH Dosierung Blockgrund"
    entity_category: diagnostic
    lambda: |-
      if (id(dose_ph_correction).is_running()) {
        return {"dosing"};
      }
      if (!id(hydroknoten_online).state) {
        return {"hydroknoten offline"};
      }
      if (!id(stir_time_elapsed).state) {
        return {"rÃ¼hrzeit abwarten"};
      }
      if (id(pump_d_total_today) >= id(pump_d_max_ml_day).state) {
        return {"tageslimit pumpe d"};
      }
      return {"ok"};
    update_interval: 5s
    # Klarer Blockgrund fÃ¼r HA-Dashboard

# ===============================================================
# BINARY SENSOREN (HEALTH CHECKS, SAFETY ALARMS)
# ===============================================================

binary_sensor:
  - platform: status
    name: "Status verbunden"
    device_class: connectivity
    entity_category: diagnostic

  # RÃ¼hrzeit Check (TRUE = Dosierung erlaubt)
  - platform: template
    name: "RÃ¼hrzeit abgelaufen"
    id: stir_time_elapsed
    entity_category: diagnostic
    lambda: |-
      float min_wait = id(min_stir_time_between_doses).state;
      float time_passed = id(time_since_last_dose).state;
      return time_passed >= min_wait;

  # Hydroknoten Online Check
  - platform: template
    name: "Hydroknoten Online"
    id: hydroknoten_online
    device_class: connectivity
    entity_category: diagnostic
    lambda: |-
      // Check ob EC-Wert aktualisiert wird (nicht NaN)
      return !isnan(id(ec_current).state) && !isnan(id(ph_current).state);

  # Safety Limits (90% Warnung)
  - platform: template
    name: "Pumpe A â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_a_total_today) >= (id(pump_a_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe B â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_b_total_today) >= (id(pump_b_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe C â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_c_total_today) >= (id(pump_c_max_ml_day).state * 0.9);

  - platform: template
    name: "Pumpe D â€“ Safety Limit Warning"
    entity_category: diagnostic
    lambda: |-
      return id(pump_d_total_today) >= (id(pump_d_max_ml_day).state * 0.9);

  # Tageslimit erreicht (harte Grenze)
  - platform: template
    name: "Pumpe A â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_a_total_today) >= id(pump_a_max_ml_day).state;

  - platform: template
    name: "Pumpe B â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_b_total_today) >= id(pump_b_max_ml_day).state;

  - platform: template
    name: "Pumpe C â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_c_total_today) >= id(pump_c_max_ml_day).state;

  - platform: template
    name: "Pumpe D â€“ Tageslimit erreicht"
    entity_category: diagnostic
    lambda: |-
      return id(pump_d_total_today) >= id(pump_d_max_ml_day).state;

  # Irgendeine Pumpe aktiv?
  - platform: template
    name: "Dosierung aktiv"
    lambda: |-
        return id(pump1_switch).state || id(pump2_switch).state || 
               id(pump3_switch).state || id(pump4_switch).state;

# ===============================================================
# BUTTONS (RESTART, DAILY RESET)
# ===============================================================
button:
  - platform: restart
    name: "Dosierung â€“ Restart"

  - platform: safe_mode
    name: "Dosierung â€“ Safe Mode"

  - platform: template
    name: "Reset Tages-Counter"
    on_press:
      - logger.log: "ğŸ”„ Tages-Counter zurÃ¼ckgesetzt"
      - lambda: |-
          id(pump_a_total_today) = 0.0;
          id(pump_b_total_today) = 0.0;
          id(pump_c_total_today) = 0.0;
          id(pump_d_total_today) = 0.0;

# ===============================================================
# SCRIPTS (DOSIER-LOGIK, DAILY RESET)
# ===============================================================
script:
    - id: daily_reset_script
      mode: single
      then:
        - logger.log: "ğŸŒ… Mitternacht â€“ Tages-Counter Reset"
        - lambda: |-
            id(pump_a_total_today) = 0.0;
            id(pump_b_total_today) = 0.0;
            id(pump_c_total_today) = 0.0;
            id(pump_d_total_today) = 0.0;

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE EC-DOSIERUNG (Pumpe A)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ec_nutrients
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ EC-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ec_nutrients

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ EC-Dosierung abgebrochen"
              - script.stop: dose_ec_nutrients

        # STEP 3: EC-Berechnung
        - lambda: |-
            float ec_diff = id(ec_target).state - id(ec_current).state;

            if (ec_diff < 0.05) {
              ESP_LOGI("dose_ec", "âœ“ EC bereits im Zielbereich (%.2f mS/cm)", id(ec_current).state);
              return;
            }

            float system_liters = id(system_volume_liters).state;
            float ec_per_ml_100L = id(pump_a_ec_per_ml).state;
            float ec_per_ml_actual = ec_per_ml_100L * (100.0 / system_liters);
            float ml_needed = ec_diff / ec_per_ml_actual;

            float max_cycle = id(max_dose_per_cycle).state;
            if (ml_needed > max_cycle) {
              ESP_LOGW("dose_ec", "âš ï¸ Begrenzt auf %.0f ml (berechnet: %.1f ml)", max_cycle, ml_needed);
              ml_needed = max_cycle;
            }

            if (id(pump_a_total_today) + ml_needed > id(pump_a_max_ml_day).state) {
              ESP_LOGE("dose_ec", "âŒ Tageslimit erreicht! (%.0f/%.0f ml)", id(pump_a_total_today), id(pump_a_max_ml_day).state);
              return;
            }

            ESP_LOGI("dose_ec", "ğŸ’§ Dosiere %.1f ml DÃ¼nger (EC: %.2f â†’ %.2f mS/cm)", ml_needed, id(ec_current).state, id(ec_target).state);

            float flow_rate = id(pump_a_flow_ml_per_sec).state;
            float seconds = ml_needed / flow_rate;
            id(pump1_output).set_level(1.0);
            delay((int)(seconds * 1000));
            id(pump1_output).set_level(0.0);

            id(pump_a_total_today) += ml_needed;
            id(pump_a_lifetime_ml) += ml_needed;
            id(pump_a_cycles) += 1;
            id(last_dose_timestamp) = millis();

            ESP_LOGI("dose_ec", "âœ“ Pumpe A: %.1f ml dosiert (heute: %.0f ml)", ml_needed, id(pump_a_total_today));

        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - logger.log: "âœ“ EC-Dosierung + RÃ¼hrvorgang abgeschlossen"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INTELLIGENTE pH-DOSIERUNG (Pumpe B/C)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - id: dose_ph_correction
      mode: single
      then:
        # STEP 1: RÃ¼hrzeit-Check
        - if:
            condition:
              lambda: 'return !id(stir_time_elapsed).state;'
            then:
              - logger.log:
                  format: "â³ pH-Dosierung blockiert â€“ RÃ¼hrzeit noch %.0f Sekunden"
                  args: ['id(min_stir_time_between_doses).state - id(time_since_last_dose).state']
              - script.stop: dose_ph_correction

        # STEP 2: Hydroknoten Online?
        - if:
            condition:
              lambda: 'return !id(hydroknoten_online).state;'
            then:
              - logger.log: "âŒ Hydroknoten offline â€“ pH-Dosierung abgebrochen"
              - script.stop: dose_ph_correction

        # STEP 3: pH-Berechnung (nur pH Down Ã¼ber Pumpe D)
        - lambda: |-
            float ph_diff = id(ph_target).state - id(ph_current).state;

            if (abs(ph_diff) < 0.1) {
              ESP_LOGI("dose_ph", "âœ“ pH bereits im Zielbereich (%.2f)", id(ph_current).state);
              return;
            }

            if (ph_diff > 0.1) {
              ESP_LOGW("dose_ph", "âš ï¸ pH zu niedrig â€“ pH Up nicht vorhanden");
              return;
            }

            float system_liters = id(system_volume_liters).state;
            float ph_per_ml_100L = id(ph_down_per_ml).state;
            float ph_per_ml_actual = ph_per_ml_100L * (100.0 / system_liters);
            float ml_needed = abs(ph_diff) / ph_per_ml_actual;
            ESP_LOGI("dose_ph", "ğŸ“‰ pH zu hoch â€“ pH Down benÃ¶tigt");

            float max_cycle = id(max_dose_per_cycle).state;
            if (ml_needed > max_cycle) {
              ESP_LOGW("dose_ph", "âš ï¸ Begrenzt auf %.0f ml (berechnet: %.1f ml)", max_cycle, ml_needed);
              ml_needed = max_cycle;
            }

            float* today_counter = &id(pump_d_total_today);
            float max_day = id(pump_d_max_ml_day).state;

            if (*today_counter + ml_needed > max_day) {
              ESP_LOGE("dose_ph", "âŒ Tageslimit Pumpe D erreicht!");
              return;
            }

            ESP_LOGI("dose_ph", "ğŸ’§ Dosiere %.1f ml (pH: %.2f â†’ %.2f)", ml_needed, id(ph_current).state, id(ph_target).state);

            float flow_rate = id(pump_d_flow_ml_per_sec).state;
            float seconds = ml_needed / flow_rate;

            id(pump4_output).set_level(1.0);
            delay((int)(seconds * 1000));
            id(pump4_output).set_level(0.0);
            id(pump_d_total_today) += ml_needed;
            id(pump_d_lifetime_ml) += ml_needed;
            id(pump_d_cycles) += 1;

            id(last_dose_timestamp) = millis();
            ESP_LOGI("dose_ph", "âœ“ Pumpe D: %.1f ml dosiert", ml_needed);
        # STEP 4: RÃ¼hrmotor aktivieren
        - logger.log: "ğŸŒ€ RÃ¼hrmotor gestartet"
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - delay: !lambda 'return id(stir_time).state * 1000;'
        - lambda: |-
            // MCP4131 deaktiviert (Hardware fehlt).
            return;
        - logger.log: "âœ“ pH-Dosierung + RÃ¼hrvorgang abgeschlossen"
# ===============================================================
# INTERVAL (DAILY RESET UM 00:00)
# ===============================================================
interval:
  - interval: 1h
    then:
      - lambda: |-
          auto time = id(ha_time).now();
          if (time.hour == 0 && time.minute == 0) {
            id(daily_reset_script).execute();
          }



################################################################################
# COPILOT-ANWEISUNG â€“ BITTE VOR JEDER CODE-Ã„NDERUNG LESEN
#
# ZIEL
# Dieser ESPHome-Knoten soll ein VOLLSTÃ„NDIG AUTARKER RDWC-DOSIERCONTROLLER sein.
# SÃ¤mtliche Bedienelemente (number, switch, button, sensor) MÃœSSEN
# direkt vom ESP bereitgestellt werden.
#
# Home Assistant dient NUR als:
# - Anzeige (Dashboard)
# - Datenquelle fÃ¼r EC- und pH-Messwerte vom Hydroknoten
#
# ES DÃœRFEN KEINE NEUEN input_number / input_boolean IN HOME ASSISTANT
# VORAUSGESETZT ODER BENÃ–TIGT WERDEN.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GRUNDKONZEPT DER DOSIERUNG
#
# - Es existieren 4 Dosierpumpen (Pumpe Aâ€“D)
# - Jede Pumpe kann einen beliebigen DÃ¼nger eines Herstellers reprÃ¤sentieren
# - Jede Pumpe besitzt:
#   - EC-Wirksamkeit pro ml (EC-ErhÃ¶hung pro ml bei 100 Liter)
#   - FÃ¶rderleistung (ml pro Sekunde)
#   - Tageslimit (ml/Tag)
#   - Maximaldosis pro Zyklus (ml)
#
# - Die EC-Regelung basiert auf einer VERTEILUNGSLOGIK:
#   Die EC-Differenz zwischen Ist- und Sollwert MUSS gleichmÃ¤ÃŸig
#   auf alle AKTIVEN DÃ¼ngerpumpen verteilt werden.
#
#   Beispiele:
#   - 1 aktive Pumpe  â†’ 100 % der EC-Differenz
#   - 2 aktive Pumpen â†’ je 50 %
#   - 3 aktive Pumpen â†’ je 33,33 %
#   - 4 aktive Pumpen â†’ je 25 %
#
# - pH-Pumpen (pH Up / pH Down) sind NICHT Teil der EC-Verteilungslogik
#   und werden ausschlieÃŸlich fÃ¼r pH-Korrekturen verwendet.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ZWANGSVORGABEN FÃœR ENTITÃ„TEN (MÃœSSEN VOM ESP BEREITGESTELLT WERDEN)
#
# FÃœR JEDE PUMPE Aâ€“D:
# - switch:   Aktiv / Inaktiv (Teilnahme an EC-Verteilung)
# - button:   Manuelle Dosierung NUR dieser Pumpe
# - sensor:   Berechnete Dosiermenge (ml)
# - sensor:   Berechnete Laufzeit (Sekunden)
#
# GLOBAL:
# - button:   "Automatische EC-Dosierung starten"
# - sensor:   "Anzahl aktive DÃ¼nger"
# - sensor:   "EC-Differenz (Soll â€“ Ist)"
# - sensor:   "Dosierstatus" (idle / dosing / stirring / blocked)
#
# ALLE ENTITÃ„TEN MÃœSSEN:
# - dashboardfÃ¤hig sein
# - sprechende Namen haben
# - restorefÃ¤hig sein, wo sinnvoll
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# RÃœHRZEIT & DOSIERABLAUF (KRITISCH)
#
# - Dosierungen erfolgen IMMER SEQUENZIELL, niemals parallel
# - Nach JEDER Dosierung MUSS eine RÃ¼hrzeit abgewartet werden
# - Die RÃ¼hrzeit ist als number im ESP konfigurierbar (Sekunden)
# - Ist die RÃ¼hrzeit noch nicht abgelaufen:
#   â†’ Dosierung BLOCKIEREN
#
# Ablauf:
#   Berechnung â†’ Pumpe dosieren â†’ RÃ¼hren â†’ nÃ¤chste Pumpe
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SICHERHEITSLOGIK (DARF NICHT UMGEHEN WERDEN)
#
# - Tageslimits pro Pumpe strikt einhalten
# - Maximaldosis pro Zyklus strikt einhalten
# - Keine Dosierung wenn:
#   - Hydroknoten offline ist
#   - EC/pH-Werte ungÃ¼ltig (NaN) sind
#   - RÃ¼hrzeit noch nicht abgelaufen ist
#
# - Bei Blockierung MUSS:
#   - ein Log-Eintrag erfolgen
#   - der Dosierstatus entsprechend gesetzt werden
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ARCHITEKTUR-REGELN
#
# - KEINE while-Loops
# - KEINE blockierenden delays auÃŸerhalb von ESPHome scripts
# - Dosierlogik ausschlieÃŸlich Ã¼ber scripts + delay
# - Alle Berechnungen erfolgen lokal im ESP
#
# - Bestehende Logik darf NICHT entfernt werden
# - Erweiterungen mÃ¼ssen rÃ¼ckwÃ¤rtskompatibel sein
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DENKWEISE FÃœR COPILOT
#
# Der ESP ist die "Single Source of Truth".
# Home Assistant ist nur Anzeige & Fernbedienung.
#
# Wenn du unsicher bist:
# â†’ NICHT vereinfachen
# â†’ NICHT entfernen
# â†’ bestehende Sicherheitslogik priorisieren
################################################################################
