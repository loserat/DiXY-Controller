################################################################################
# DiXY RDWC Controller - Hydroknoten v0.2-beta
# 
# Funktion: Nährstoff-Monitoring + Wasserstandsüberwachung
# Hardware: ESP32-DevKit
# 
# GPIO PINOUT:
# ├─ I2C Bus (SDA=21, SCL=22):
# │  ├─ SSD1306 OLED Display (0x3C)
# │  └─ ADS1115 ADC (0x48) für EC + pH
# ├─ Encoder Menü:
# │  ├─ GPIO25: Rotary CLK
# │  ├─ GPIO27: Rotary DT  
# │  └─ GPIO26: Rotary Button
# ├─ DS18B20 Temperatursensor:
# │  └─ GPIO4: OneWire Bus
# ├─ Wasserstandssensoren D1CS-D (capacitive):
# │  ├─ GPIO32: Tank 1 Level
# │  ├─ GPIO33: Tank 2 Level
# │  ├─ GPIO14: Tank 3 Level
# │  ├─ GPIO12: Tank 4 Level
# │  ├─ GPIO13: Tank 5 Level
# │  └─ GPIO15: Tank 6 Level
# └─ Status LED:
#    └─ GPIO2: Onboard LED (Connection Status)
# 
# Sensoren:
# - EC-Sensor (Atlas Scientific/Analog via ADS1115)
# - pH-Sensor (Atlas Scientific/Analog via ADS1115)
# - DS18B20 Wassertemperatur
# - 6x D1CS-D Kapazitive Wasserstandssensoren (Digital GPIO)
# 
# Features:
# - OLED-Menü mit Rotary Encoder (Kalibrierung, Offsets, Live-Werte)
# - 2-Punkt-Kalibrierung (EC: 1.41 + 12.88 mS/cm, pH: 4.0 + 7.0)
# - Persistente Offsets in Flash
# - Wasserverbrauch-Tracking für KI Stress-Detektion
# - WiFi Diagnostics, Health Checks, Kalibrier-Timestamps
################################################################################

substitutions:
  device_name: hydroknoten
  friendly_name: "Hydroknoten"
  device_description: "Nährstoff + Wasserstand Monitoring"
  project_version: "0.2-beta"
  
  # I2C Pins
  i2c_sda_pin: "21"
  i2c_scl_pin: "22"
  
  # OneWire Pins (DS18B20)
  onewire_pin1: "4"
  onewire_pin2: "5"
  
  # Encoder Pins
  encoder_clk_pin: "27"
  encoder_dt_pin: "26"
  encoder_btn_pin: "25"
  
  # Water level GPIO (digital D1CS-D)
  tank1_pin: "32"
  tank2_pin: "33"
  tank3_pin: "14"
  tank4_pin: "12"
  tank5_pin: "13"
  tank6_pin: "15"
  
  # ADS1115 I2C address
  ads1115_address: "0x48"

esphome:
  name: hydroknoten
  friendly_name: Hydroknoten
  comment: "DiXY Hydroknoten v0.2-beta – EC + pH + DS18B20 + OLED + Wasserstand + Diagnostics"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# ===============================================================
# LOGGING
# ===============================================================
logger:
  level: INFO
  baud_rate: 115200

# ===============================================================
# WLAN
# ===============================================================
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret hydroknoten_ap_ssid
    password: !secret hydroknoten_ap_password

# ===============================================================
# OTA
# ===============================================================
ota:
  platform: esphome
  password: !secret hydroknoten_ota_password

# ===============================================================
# API
# ===============================================================
api:
  reboot_timeout: 0s

# ===============================================================
# WEB-DASHBOARD
# ===============================================================
web_server:
  port: 80

# ===============================================================
# ZEIT
# ===============================================================
time:
  - platform: homeassistant
    id: ha_time

# ===============================================================
# I2C BUS (OLED SSD1306 + ADS1115)
# ===============================================================
i2c:
  sda: ${i2c_sda_pin}
  scl: ${i2c_scl_pin}
  scan: true
  frequency: 400kHz
  id: bus_i2c

# ===============================================================
# GLOBALS – ENCODER-MENÜ STATE MANAGEMENT
# ===============================================================
globals:
  # Menü-Navigation
  - id: menu_state
    type: int
    initial_value: '0'  # 0=Home, 1=MainMenu, 2=SubMenu
  
  - id: menu_selection
    type: int
    initial_value: '1'  # Aktuelle Auswahl (1-6)
  
  - id: current_page
    type: int
    initial_value: '0'  # 0=Home, 1=EC-Kalib, 2=pH-Kalib, 3=Offsets
  
  - id: calibration_step
    type: int
    initial_value: '0'  # Welcher Schritt wird kalibriert: 0=Aus, 1=EC-Low, 2=EC-High, 3=pH-Low, 4=pH-High
  
  - id: encoder_last_state
    type: bool
    initial_value: 'false'  # Für Encoder-Debouncing

  # Kalibrierungs-Timestamps (Unix Sekunden)
  - id: last_ec_cal_ts
    type: uint32_t
    initial_value: '0'

  - id: last_ph_cal_ts
    type: uint32_t
    initial_value: '0'

# ===============================================================
# DISPLAY / OLED SSD1306
# ===============================================================
font:
  - file: "fonts/arial.ttf"
    id: font_small
    size: 12

display:
  - platform: ssd1306_i2c
    i2c_id: bus_i2c
    id: oled
    model: "SSD1306 128x64"
    update_interval: 0.2s
    pages:
      # PAGE 0: HOME (Sensor-Anzeige)
      - id: page_home
        lambda: |-
          if (id(menu_state) == 0) {
            it.printf(0, 0, id(font_small), "Hydroknoten v3.0");
            it.printf(0, 15, id(font_small), "EC: %.2f mS/cm", id(ec_value).state);
            it.printf(0, 30, id(font_small), "pH: %.2f", id(ph_value).state);
            it.printf(0, 45, id(font_small), "T1: %.1fC", id(temp1_corr).state);
            it.printf(70, 45, id(font_small), "T2: %.1fC", id(temp2_corr).state);
            it.printf(0, 58, id(font_small), ">>> ROT zum Menue <<<");
          }

      # PAGE 1: HAUPTMENÜ
      - id: page_main_menu
        lambda: |-
          if (id(menu_state) == 1) {
            it.printf(5, 0, id(font_small), "=== HAUPTMENU ===");
            
            const char* options[] = {
              "1) Sensor-Anzeige",
              "2) EC Kalibrieren",
              "3) pH Kalibrieren",
              "4) Offsets anpassen",
              "5) Werkseinstellung",
              "6) Zurueck"
            };
            
            for (int i = 1; i <= 6; i++) {
              int y_pos = 10 + (i-1) * 8;
              if (i == id(menu_selection)) {
                it.printf(5, y_pos, id(font_small), "> %s", options[i-1]);
              } else {
                it.printf(5, y_pos, id(font_small), "  %s", options[i-1]);
              }
            }
          }

      # PAGE 2: EC KALIBRIERUNG
      - id: page_ec_calib
        lambda: |-
          if (id(menu_state) == 2 && id(current_page) == 1) {
            it.printf(0, 0, id(font_small), "= EC KALIBRIERUNG =");
            it.printf(0, 15, id(font_small), "Raw: %.3fV", id(ec_raw).state * 3.3);
            it.printf(0, 30, id(font_small), "EC: %.2f mS/cm", id(ec_value).state);
            
            if (id(calibration_step) == 1) {
              it.printf(0, 45, id(font_small), "LOW: ROT justieren");
              it.printf(0, 58, id(font_small), "LOW: %.3fV speichern", id(ec_cal_low).state);
            } else if (id(calibration_step) == 2) {
              it.printf(0, 45, id(font_small), "HIGH: ROT justieren");
              it.printf(0, 58, id(font_small), "HIGH: %.3fV speichern", id(ec_cal_high).state);
            } else {
              it.printf(0, 45, id(font_small), "Schritt waehlen:");
              it.printf(0, 58, id(font_small), "1=Low, 2=High, Back");
            }
          }

      # PAGE 3: pH KALIBRIERUNG
      - id: page_ph_calib
        lambda: |-
          if (id(menu_state) == 2 && id(current_page) == 2) {
            it.printf(0, 0, id(font_small), "= pH KALIBRIERUNG =");
            it.printf(0, 15, id(font_small), "Raw: %.3fV", id(ph_raw).state * 3.3);
            it.printf(0, 30, id(font_small), "pH: %.2f", id(ph_value).state);
            
            if (id(calibration_step) == 3) {
              it.printf(0, 45, id(font_small), "pH4: ROT justieren");
              it.printf(0, 58, id(font_small), "pH4: %.3fV speichern", id(ph_cal_4).state);
            } else if (id(calibration_step) == 4) {
              it.printf(0, 45, id(font_small), "pH7: ROT justieren");
              it.printf(0, 58, id(font_small), "pH7: %.3fV speichern", id(ph_cal_7).state);
            } else {
              it.printf(0, 45, id(font_small), "Schritt waehlen:");
              it.printf(0, 58, id(font_small), "1=pH4, 2=pH7, Back");
            }
          }

      # PAGE 4: OFFSETS ANPASSEN
      - id: page_offsets
        lambda: |-
          if (id(menu_state) == 2 && id(current_page) == 3) {
            it.printf(0, 0, id(font_small), "= OFFSETS ANPASSEN =");
            it.printf(0, 15, id(font_small), "T1 Off: %.1f°C", id(temp1_offset).state);
            it.printf(0, 30, id(font_small), "T2 Off: %.1f°C", id(temp2_offset).state);
            it.printf(0, 45, id(font_small), "ROT drehen/drucken");
            it.printf(0, 58, id(font_small), "Speichern: OK");
          }

# ===============================================================
# DS18B20 TEMPERATURE SENSORS
# ===============================================================
dallas:
  - pin: 4
  - pin: 5

# ===============================================================
# BINARY SENSORS – ENCODER BUTTONS
# ===============================================================
binary_sensor:
  # Encoder Push-Button (GPIO 25)
  - platform: gpio
    id: encoder_button
    pin:
      number: GPIO25
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: |-
            // Button-Logik für Menü-Navigation
            if (id(menu_state) == 0) {
              // HOME → Hauptmenü öffnen
              id(menu_state) = 1;
              id(menu_selection) = 1;
            } else if (id(menu_state) == 1) {
              // Hauptmenü → SubMenu/Aktion
              if (id(menu_selection) == 1) {
                id(menu_state) = 0; // Zurück zu Sensor-Anzeige
              } else if (id(menu_selection) == 2) {
                id(menu_state) = 2; // EC-Kalibrierung
                id(current_page) = 1;
                id(calibration_step) = 0;
              } else if (id(menu_selection) == 3) {
                id(menu_state) = 2; // pH-Kalibrierung
                id(current_page) = 2;
                id(calibration_step) = 0;
              } else if (id(menu_selection) == 4) {
                id(menu_state) = 2; // Offsets anpassen
                id(current_page) = 3;
              } else if (id(menu_selection) == 5) {
                // Werkseinstellung zurücksetzen
                id(ec_cal_low) = 0.104;
                id(ec_cal_high) = 1.598;
                id(ph_cal_4) = 3.00;
                id(ph_cal_7) = 2.50;
                id(temp1_offset) = 0.0;
                id(temp2_offset) = 0.0;
                id(menu_state) = 0;
              } else if (id(menu_selection) == 6) {
                id(menu_state) = 0; // Zurück
              }
            } else if (id(menu_state) == 2) {
              // Im SubMenu
              if (id(current_page) == 1) {
                // EC-Kalibrierung: Schritt wählen oder speichern
                if (id(calibration_step) == 0) {
                  // Schritt 1 oder 2 wählen via menu_selection
                  if (id(menu_selection) == 1) {
                    id(calibration_step) = 1; // EC Low
                  } else if (id(menu_selection) == 2) {
                    id(calibration_step) = 2; // EC High
                  } else {
                    id(menu_state) = 1; // Zurück
                    id(menu_selection) = 2;
                  }
                } else {
                  // Wert speichern & nächster Schritt
                  if (id(calibration_step) == 1) {
                    id(calibration_step) = 2; // Zu EC High
                  } else {
                    id(menu_state) = 1; // Fertig, Hauptmenü
                    id(menu_selection) = 1;
                  }
                }
              } else if (id(current_page) == 2) {
                // pH-Kalibrierung
                if (id(calibration_step) == 0) {
                  if (id(menu_selection) == 1) {
                    id(calibration_step) = 3; // pH 4.0
                  } else if (id(menu_selection) == 2) {
                    id(calibration_step) = 4; // pH 7.0
                  } else {
                    id(menu_state) = 1; // Zurück
                    id(menu_selection) = 3;
                  }
                } else {
                  if (id(calibration_step) == 3) {
                    id(calibration_step) = 4; // Zu pH 7.0
                  } else {
                    id(menu_state) = 1; // Fertig
                    id(menu_selection) = 1;
                  }
                }
              } else if (id(current_page) == 3) {
                // Offsets speichern & Menü
                id(menu_state) = 1;
                id(menu_selection) = 4;
              }
            }
            id(oled)->update();

  # Encoder CLK (GPIO 27) für Drehrichtung
  - platform: gpio
    id: encoder_clk
    pin:
      number: GPIO27
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 5ms
    on_press:
      then:
        - lambda: |-
            // CLK ist fallende Flanke → Check DT für Richtung
            bool dt_state = id(encoder_dt).state;
            
            if (id(menu_state) == 1) {
              // Im Hauptmenü navigieren
              if (!dt_state) {
                // CLK low, DT high → Vorwärts (CW)
                id(menu_selection)++;
                if (id(menu_selection) > 6) id(menu_selection) = 1;
              } else {
                // CLK low, DT low → Rückwärts (CCW)
                id(menu_selection)--;
                if (id(menu_selection) < 1) id(menu_selection) = 6;
              }
            } else if (id(menu_state) == 2) {
              // Im Kalibrierungs-/Offset-SubMenu
              if (id(current_page) == 3) {
                // Offsets anpassen (T1/T2)
                // menu_selection 1 = T1, 2 = T2, 6 = Back
                if (id(menu_selection) == 1) {
                  if (!dt_state) {
                    id(temp1_offset) += 0.1;
                    if (id(temp1_offset) > 2.0) id(temp1_offset) = 2.0;
                  } else {
                    id(temp1_offset) -= 0.1;
                    if (id(temp1_offset) < -2.0) id(temp1_offset) = -2.0;
                  }
                } else if (id(menu_selection) == 2) {
                  if (!dt_state) {
                    id(temp2_offset) += 0.1;
                    if (id(temp2_offset) > 2.0) id(temp2_offset) = 2.0;
                  } else {
                    id(temp2_offset) -= 0.1;
                    if (id(temp2_offset) < -2.0) id(temp2_offset) = -2.0;
                  }
                }
              } else {
                // EC/pH Kalibrierung: Kalibrierwerte justieren
                if (id(calibration_step) == 1) {
                  // EC Low anpassen
                  if (!dt_state) {
                    id(ec_cal_low) += 0.001;
                    if (id(ec_cal_low) > 1.0) id(ec_cal_low) = 1.0;
                  } else {
                    id(ec_cal_low) -= 0.001;
                    if (id(ec_cal_low) < 0.05) id(ec_cal_low) = 0.05;
                  }
                } else if (id(calibration_step) == 2) {
                  // EC High anpassen
                  if (!dt_state) {
                    id(ec_cal_high) += 0.001;
                    if (id(ec_cal_high) > 3.3) id(ec_cal_high) = 3.3;
                  } else {
                    id(ec_cal_high) -= 0.001;
                    if (id(ec_cal_high) < 1.0) id(ec_cal_high) = 1.0;
                  }
                } else if (id(calibration_step) == 3) {
                  // pH 4.0 anpassen
                  if (!dt_state) {
                    id(ph_cal_4) += 0.01;
                    if (id(ph_cal_4) > 4.0) id(ph_cal_4) = 4.0;
                  } else {
                    id(ph_cal_4) -= 0.01;
                    if (id(ph_cal_4) < 1.0) id(ph_cal_4) = 1.0;
                  }
                } else if (id(calibration_step) == 4) {
                  // pH 7.0 anpassen
                  if (!dt_state) {
                    id(ph_cal_7) += 0.01;
                    if (id(ph_cal_7) > 4.0) id(ph_cal_7) = 4.0;
                  } else {
                    id(ph_cal_7) -= 0.01;
                    if (id(ph_cal_7) < 1.0) id(ph_cal_7) = 1.0;
                  }
                }
              }
            }
            id(oled)->update();

  # Encoder DT (GPIO 26) – nur für Status-Abfrage
  - platform: gpio
    id: encoder_dt
    pin:
      number: GPIO26
      mode: INPUT_PULLUP
      inverted: true

  # Status Online
  - platform: status
    name: "Hydroknoten Online"

# ===============================================================
# WASSERSTAND-SENSOREN (D1CS-D Digital GPIO)
# ===============================================================
# 6x D1CS-D kapazitive Sensoren - Digital Output (HIGH = kein Wasser, LOW = Wasser)
# Anschluss: VCC=3.3V, GND, OUT=GPIO
# ===============================================================

  # Tank 1 Wasserstand (GPIO 32)
  - platform: gpio
    name: "Tank 1 Wasserstand"
    id: tank1_level
    pin:
      number: GPIO32
      mode: INPUT_PULLUP
      inverted: true  # Invertiert: ON = Wasser erkannt, OFF = kein Wasser
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Tank 2 Wasserstand (GPIO 33)
  - platform: gpio
    name: "Tank 2 Wasserstand"
    id: tank2_level
    pin:
      number: GPIO33
      mode: INPUT_PULLUP
      inverted: true
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Tank 3 Wasserstand (GPIO 14)
  - platform: gpio
    name: "Tank 3 Wasserstand"
    id: tank3_level
    pin:
      number: GPIO14
      mode: INPUT_PULLUP
      inverted: true
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Tank 4 Wasserstand (GPIO 12)
  - platform: gpio
    name: "Tank 4 Wasserstand"
    id: tank4_level
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Tank 5 Wasserstand (GPIO 13)
  - platform: gpio
    name: "Tank 5 Wasserstand"
    id: tank5_level
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Tank 6 Wasserstand (GPIO 15)
  - platform: gpio
    name: "Tank 6 Wasserstand"
    id: tank6_level
    pin:
      number: GPIO15
      mode: INPUT_PULLUP
      inverted: true
    device_class: moisture
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s

  # Any tank empty (alerts if any level sensor reports "leer")
  - platform: template
    name: "Tank Leer (mindestens einer)"
    id: any_tank_empty
    device_class: problem
    lambda: |-
      return !id(tank1_level).state || !id(tank2_level).state || !id(tank3_level).state ||
             !id(tank4_level).state || !id(tank5_level).state || !id(tank6_level).state;
    filters:
      - delayed_on: 1s
      - delayed_off: 5s

  # Health: ADS1115 + EC/pH Signal plausibility
  - platform: template
    name: "ADS1115 Fehler"
    id: ads1115_fault
    device_class: problem
    lambda: |-
      return isnan(id(ec_raw).state) || isnan(id(ph_raw).state);
    filters:
      - delayed_on: 2s
      - delayed_off: 5s

  # Health: DS18B20 presence
  - platform: template
    name: "Temperatursensoren Fehler"
    id: temps_fault
    device_class: problem
    lambda: |-
      return isnan(id(temp1_raw).state) || isnan(id(temp2_raw).state);
    filters:
      - delayed_on: 5s
      - delayed_off: 5s

# ===============================================================
# ALLE SENSOREN (nur 1 sensor:-Block!)
# ===============================================================
sensor:
  # ------------------ SYSTEM ------------------
  - platform: wifi_signal
    id: hydro_wifi_signal
    name: "WiFi Signal"
    unit_of_measurement: "dBm"
    state_class: measurement
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    unit_of_measurement: "h"
    state_class: total_increasing
    update_interval: 60s

  - platform: internal_temperature
    name: "ESP32 Chip Temperatur"
    unit_of_measurement: "°C"
    state_class: measurement
    update_interval: 30s

  - platform: template
    name: "Free Heap"
    unit_of_measurement: "kB"
    state_class: measurement
    lambda: |-
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0;
    update_interval: 60s

  # ------------------ DS18B20 ------------------
  - platform: dallas
    address: 0x0000000000000001
    name: "Tank Temp Roh"
    id: temp1_raw
    state_class: measurement

  - platform: dallas
    address: 0x0000000000000002
    name: "Rücklauf Temp Roh"
    id: temp2_raw
    state_class: measurement

  # korrigierte Temperaturen
  - platform: template
    name: "Tank Temp"
    id: temp1_corr
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
      return id(temp1_raw).state + id(temp1_offset).state;
    update_interval: 10s

  - platform: template
    name: "Rücklauf Temp"
    id: temp2_corr
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
      return id(temp2_raw).state + id(temp2_offset).state;
    update_interval: 10s

  # ------------------ ADS1115 16-BIT ADC ------------------
  - platform: ads1115
    multiplexer: "A0"
    gain: 6.144
    id: ec_raw
    name: "EC Raw Voltage (ADS1115)"
    unit_of_measurement: "V"
    state_class: measurement
    update_interval: 1s

  - platform: ads1115
    multiplexer: "A1"
    gain: 6.144
    id: ph_raw
    name: "PH Raw Voltage (ADS1115)"
    unit_of_measurement: "V"
    state_class: measurement
    update_interval: 1s

  # ------------------ EC FORMEL ------------------
  - platform: template
    name: "EC Wert"
    id: ec_value
    unit_of_measurement: "mS/cm"
    accuracy_decimals: 2
    device_class: conductivity
    state_class: measurement
    lambda: |-
      float v = id(ec_raw).state * 3.3;
      float v_low = id(ec_cal_low).state;
      float v_high = id(ec_cal_high).state;

      float slope = (12.88 - 1.413) / (v_high - v_low);
      float offset = 1.413 - slope * v_low;
      float ec = slope * v + offset;
      if(ec < 0) ec = 0;

      float t = id(temp1_corr).state;
      if(isnan(t)) return ec;

      float ec25 = ec / (1 + 0.0185*(t - 25.0));
      return ec25;
    update_interval: 10s

  # ------------------ PH FORMEL ------------------
  - platform: template
    name: "pH Wert"
    id: ph_value
    unit_of_measurement: "pH"
    accuracy_decimals: 2
    state_class: measurement
    lambda: |-
      float v = id(ph_raw).state * 3.3;
      float v7 = id(ph_cal_7).state;
      float v4 = id(ph_cal_4).state;
      float m = (4.0 - 7.0) / (v4 - v7);
      float ph = m * (v - v7) + 7.0;
      return ph;
    update_interval: 10s

# ===============================================================
# TEXT / STATUS SENSOREN
# ===============================================================
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Adresse"
    ssid:
      name: "Verbundenes WLAN"
    bssid:
      name: "Access Point BSSID"
    mac_address:
      name: "MAC Adresse"

  - platform: version
    name: "ESPHome Version"

  - platform: template
    name: "Projekt Version"
    lambda: |-
      return {std::string("v0.2-beta")};
    update_interval: 60s

  - platform: template
    name: "Hydroknoten – Status Zusammenfassung"
    lambda: |-
      char buffer[256];
      snprintf(buffer, sizeof(buffer),
        "EC: %.2f mS/cm, pH: %.2f, T1: %.1f°C, T2: %.1f°C, WiFi: %d dBm",
        id(ec_value).state,
        id(ph_value).state,
        id(temp1_corr).state,
        id(temp2_corr).state,
        (int)id(hydro_wifi_signal).state
      );
      return std::string(buffer);
    update_interval: 10s

  - platform: template
    name: "EC Kalibrierung zuletzt"
    lambda: |-
      if (id(last_ec_cal_ts) == 0) {
        return std::string("nie");
      }
      auto now = id(ha_time).now();
      if (!now.is_valid()) {
        return std::string("Zeit unbekannt");
      }
      time_t ts = static_cast<time_t>(id(last_ec_cal_ts));
      char buf[32];
      strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M", localtime(&ts));
      return std::string(buf);
    update_interval: 60s

  - platform: template
    name: "pH Kalibrierung zuletzt"
    lambda: |-
      if (id(last_ph_cal_ts) == 0) {
        return std::string("nie");
      }
      auto now = id(ha_time).now();
      if (!now.is_valid()) {
        return std::string("Zeit unbekannt");
      }
      time_t ts = static_cast<time_t>(id(last_ph_cal_ts));
      char buf[32];
      strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M", localtime(&ts));
      return std::string(buf);
    update_interval: 60s

# ===============================================================
# NUMBER / OFFSETS / KALIBRIERUNG (nur 1 Block!)
# ===============================================================
number:
  # Temperatur Offsets
  - platform: template
    name: "Temp1 Offset"
    id: temp1_offset
    min_value: -2
    max_value: 2
    step: 0.1
    restore_value: true

  - platform: template
    name: "Temp2 Offset"
    id: temp2_offset
    min_value: -2
    max_value: 2
    step: 0.1
    restore_value: true

  # EC Kalibrierpunkte
  - platform: template
    name: "EC Kalibrierpunkt 1413µS"
    id: ec_cal_low
    min_value: 0.05
    max_value: 1.0
    step: 0.001
    restore_value: true
    initial_value: 0.104

  - platform: template
    name: "EC Kalibrierpunkt 12.88mS"
    id: ec_cal_high
    min_value: 1.0
    max_value: 3.3
    step: 0.001
    restore_value: true
    initial_value: 1.598

  # pH Kalibrierpunkte
  - platform: template
    name: "pH Kalibrierpunkt 7.0"
    id: ph_cal_7
    min_value: 1.0
    max_value: 4.0
    step: 0.01
    restore_value: true
    initial_value: 2.50

  - platform: template
    name: "pH Kalibrierpunkt 4.0"
    id: ph_cal_4
    min_value: 1.0
    max_value: 4.0
    step: 0.01
    restore_value: true
    initial_value: 3.00

# ===============================================================
# BUTTONS – SERVICE-AKTIONEN
# ===============================================================
button:
  - platform: restart
    name: "Hydroknoten Neustart"

  - platform: template
    name: "EC Kalibrierung markieren"
    on_press:
      then:
        - lambda: |-
            auto now = id(ha_time).now();
            if (now.is_valid()) {
              id(last_ec_cal_ts) = now.timestamp;
            }

  - platform: template
    name: "pH Kalibrierung markieren"
    on_press:
      then:
        - lambda: |-
            auto now = id(ha_time).now();
            if (now.is_valid()) {
              id(last_ph_cal_ts) = now.timestamp;
            }
