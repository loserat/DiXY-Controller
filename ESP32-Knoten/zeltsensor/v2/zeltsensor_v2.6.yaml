esphome:
  name: zeltsensor
  comment: "Minimalprofil BMP280 + AS7341"
  project:
    name: "loserat.dixy_zeltsensor"
    version: "2.6"
  on_boot:
    priority: -100
    then:
      - if:
          condition:
            lambda: 'return id(sun_ramp_enabled);'
          then:
            - switch.turn_on: zeltlampe_sun_ramp_switch
          else:
            - switch.turn_off: zeltlampe_sun_ramp_switch

time:
  - platform: sntp
    id: esphome_time

globals:
  # Persistente Parameter und State für die Lichtsteuerung
  - id: light_mode
    type: int
    restore_value: yes
    initial_value: '0'      # 0=NONE, 1=MANUAL, 2=AUTO
  - id: on_minutes
    type: int
    restore_value: yes
    initial_value: '480'    # 08:00 Uhr
  - id: off_minutes
    type: int
    restore_value: yes
    initial_value: '1200'   # 20:00 Uhr
  - id: max_pwm
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: manual_pwm
    type: float
    restore_value: yes
    initial_value: '0.5'
  - id: sa_start_minutes
    type: int
    restore_value: yes
    initial_value: '480'
  - id: su_start_minutes
    type: int
    restore_value: yes
    initial_value: '1200'
  - id: sun_ramp_enabled
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: sunrise_min
    type: int
    restore_value: yes
    initial_value: '10'
  - id: sunset_min
    type: int
    restore_value: yes
    initial_value: '10'

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "ZELTSENSOR_Fallback"
    password: "12345678"


ota:
  platform: esphome
  password: !secret zeltsensor_ota_password

i2c:
  sda: 21
  scl: 22
  scan: true

sensor:
  - platform: template
    name: "Blatttemperatur Dummy"
    id: leaf_temp_dummy
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state_class: measurement
    update_interval: 30s
    lambda: |-
      static float leaf_temp = 26.0f;
      leaf_temp += (float((rand() % 7) - 3)) / 10.0f; // ±0.3°C
      if (leaf_temp < 20.0f) leaf_temp = 20.0f;
      if (leaf_temp > 32.0f) leaf_temp = 32.0f;
      return leaf_temp;
  # Simulierter EC-Sensor (elektrische Leitfähigkeit)
  - platform: template
    name: "EC Dummy"
    id: ec_dummy
    unit_of_measurement: "mS/cm"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 10s
    lambda: |-
      static float ec = 1.8f;
      ec += (float((rand() % 21) - 10)) / 100.0f; // ±0.10
      if (ec < 1.0f) ec = 1.0f;
      if (ec > 2.5f) ec = 2.5f;
      return ec;

  # --- Messsensoren (Sensoren-Tab in HA) ---
  - platform: template
    name: "Relative Luftfeuchte"
    id: rlf_dummy
    unit_of_measurement: "%"
    device_class: humidity
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      // Simuliere Tagesverlauf mit Sinusfunktion (max morgens, min nachmittags)
      auto t = id(esphome_time).now().hour + id(esphome_time).now().minute / 60.0;
      float amplitude = 20.0f; // Schwankung ±20%
      float base = 60.0f;      // Mittelwert
      float rlf = base + amplitude * sinf(3.14159 * (t - 6) / 12.0); // Maximum ca. 6 Uhr, Minimum ca. 18 Uhr
      if (rlf < 40.0f) rlf = 40.0f;
      if (rlf > 80.0f) rlf = 80.0f;
      return rlf;

  - platform: template
    name: "pH Dummy"
    id: ph_dummy
    unit_of_measurement: "pH"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 10s
    lambda: |-
      static float ph = 6.2f;
      ph += (float((rand() % 21) - 10)) / 100.0f;
      if (ph < 5.5f) ph = 5.5f;
      if (ph > 7.0f) ph = 7.0f;
      return ph;

  - platform: template
    name: "CO2 Dummy"
    id: co2_dummy
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    state_class: measurement
    update_interval: 30s
    lambda: |-
      static int co2 = 1200;
      co2 += (rand() % 21) - 10; // ±10
      if (co2 < 400) co2 = 400;
      if (co2 > 2000) co2 = 2000;
      return co2;

  - platform: template
    name: "VPD Dummy"
    id: vpd_dummy
    unit_of_measurement: "kPa"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 30s
    lambda: |-
      // VPD-Berechnung aus Temperatur und Luftfeuchte
      float temp = 24.0f; // Dummy-Wert, kann durch echten Sensor ersetzt werden
      float rlf = 60.0f;  // Dummy-Wert, kann durch echten Sensor ersetzt werden
      float es = 0.6108 * exp((17.27 * temp) / (temp + 237.3));
      float ea = es * (rlf / 100.0f);
      float vpd = es - ea;
      return vpd;

  - platform: template
    name: "Zeltlampe Helligkeit"
    id: zeltlampe_brightness_sensor
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    update_interval: 2s
    lambda: |-
      if (id(zeltlampe).current_values.is_on()) {
        return id(zeltlampe).current_values.get_brightness() * 100.0f;
      } else {
        return 0.0f;
      }

  # --- Diagnose-Sensoren (Diagnose-Tab in HA) ---
  - platform: bmp280_i2c
    address: 0x76
    temperature:
      name: "BMP280 Temperatur"
    pressure:
      name: "BMP280 Luftdruck"
    update_interval: 60s

  # --- AS7341 Spektralsensor: Alle Kanäle als Sensoren ---
  - platform: as7341
    address: 0x39
    id: as7341_sensor
    f1:
      name: "AS7341 F1 (415nm)"
      id: as7341_f1
    f2:
      name: "AS7341 F2 (445nm)"
      id: as7341_f2
    f3:
      name: "AS7341 F3 (480nm)"
      id: as7341_f3
    f4:
      name: "AS7341 F4 (515nm)"
      id: as7341_f4
    f5:
      name: "AS7341 F5 (555nm)"
      id: as7341_f5
    f6:
      name: "AS7341 F6 (590nm)"
      id: as7341_f6
    f7:
      name: "AS7341 F7 (630nm)"
      id: as7341_f7
    f8:
      name: "AS7341 F8 (680nm)"
      id: as7341_f8
    clear:
      name: "AS7341 Clear"
    nir:
      name: "AS7341 NIR"
    update_interval: 120s


  - platform: template
    name: "DS18B20 Dummy"
    id: ds18b20_dummy
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      static float t = 22.0f;
      t += (float((rand() % 20) - 10)) / 10.0f;
      if (t < 20.0f) t = 20.0f;
      if (t > 25.0f) t = 25.0f;
      return t;

  - platform: wifi_signal
    name: "ESP WiFi Signal"
    id: wifi_strength
    update_interval: 60s

  - platform: uptime
    name: "ESP Uptime"
    update_interval: 60s

  - platform: template
    name: "PPFD (µmol/m²s)"
    id: ppfd
    unit_of_measurement: "µmol/m²s"
    lambda: |-
      return (id(as7341_f2).state + id(as7341_f3).state + id(as7341_f4).state + id(as7341_f5).state + id(as7341_f6).state + id(as7341_f7).state + id(as7341_f8).state) * 0.5;
    update_interval: 60s

  - platform: template
    name: "LUX (AS7341)"
    id: lux
    unit_of_measurement: "lx"
    lambda: |-
      return (id(as7341_f1).state + id(as7341_f2).state + id(as7341_f3).state + id(as7341_f4).state + id(as7341_f5).state + id(as7341_f6).state + id(as7341_f7).state + id(as7341_f8).state) * 2.0;
    update_interval: 60s

  - platform: template
    name: "DLI (mol/m²d)"
    id: dli
    unit_of_measurement: "mol/m²d"
    lambda: |-
      return id(ppfd).state * 0.0864;
    update_interval: 60s

text_sensor:
  - platform: homeassistant
    id: auto_on_time_input
    entity_id: input_datetime.einschaltzeit
    internal: true
    on_value:
      - lambda: |-
          if (x.size() < 5) {
            return;
          }
          int hour = atoi(x.substr(0, 2).c_str());
          int minute = atoi(x.substr(3, 2).c_str());
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(on_minutes) = hour * 60 + minute;
  - platform: homeassistant
    id: auto_off_time_input
    entity_id: input_datetime.ausschaltzeit
    internal: true
    on_value:
      - lambda: |-
          if (x.size() < 5) {
            return;
          }
          int hour = atoi(x.substr(0, 2).c_str());
          int minute = atoi(x.substr(3, 2).c_str());
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(off_minutes) = hour * 60 + minute;
  - platform: template
    name: "SA Startzeit (hh:mm)"
    id: sa_start_time_text
    icon: "mdi:clock-outline"
    lambda: |-
      int minutes = id(sa_start_minutes);
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    name: "SU Startzeit (hh:mm)"
    id: su_start_time_text
    icon: "mdi:clock-outline"
    lambda: |-
      int minutes = id(su_start_minutes);
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    name: "Zeltsensor Version"
    id: zeltsensor_version
    icon: "mdi:tag"
    entity_category: diagnostic
    lambda: |-
      return {"v2.6"};
    update_interval: 3600s
  - platform: wifi_info
    ip_address:
      name: "ESP IP Adresse"
    ssid:
      name: "ESP WiFi SSID"
    bssid:
      name: "ESP WiFi BSSID"
    mac_address:
      name: "ESP MAC Adresse"
binary_sensor:
  - platform: status
    name: "ESP Status"

status_led:
  pin: 2

output:
  - platform: ledc
    pin: 25
    id: zeltlampe_pwm
  - platform: template
    id: zeltlampe_sun_ramp_output
    type: binary
    write_action:
      - lambda: |-
          id(sun_ramp_enabled) = state;

light:
  - platform: monochromatic
    name: "Zeltlampe"
    output: zeltlampe_pwm
    id: zeltlampe

switch:
  - platform: output
    name: "Zeltlampe SA/SU aktiv"
    id: zeltlampe_sun_ramp_switch
    icon: "mdi:weather-sunset"
    output: zeltlampe_sun_ramp_output
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "AUTO"
    id: auto_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(light_mode) = 2;
          if (id(manual_mode).state) {
            id(manual_mode).turn_off();
          }
    turn_off_action:
      - lambda: |-
          if (!id(manual_mode).state) {
            id(light_mode) = 0;
          }
    lambda: |-
      return id(light_mode) == 2;
  - platform: template
    name: "MANUELL"
    id: manual_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(light_mode) = 1;
          if (id(auto_mode).state) {
            id(auto_mode).turn_off();
          }
    turn_off_action:
      - lambda: |-
          if (!id(auto_mode).state) {
            id(light_mode) = 0;
          }
    lambda: |-
      return id(light_mode) == 1;

number:
  # Bedienbare Parameter für das Autark-Licht
  - platform: template
    name: "Auto Max Helligkeit"
    id: zeltlampe_max_pwm
    unit_of_measurement: "%"
    min_value: 10
    max_value: 100
    step: 1
    lambda: |-
      return id(max_pwm) * 100.0f;
    set_action:
      - lambda: |-
          float value = x / 100.0f;
          if (value < 0.0f) value = 0.0f;
          if (value > 1.0f) value = 1.0f;
          id(max_pwm) = value;
  - platform: template
    name: "Manuelle Helligkeit"
    id: zeltlampe_manual_pwm
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    lambda: |-
      return id(manual_pwm) * 100.0f;
    set_action:
      - lambda: |-
          float value = x / 100.0f;
          if (value < 0.0f) value = 0.0f;
          if (value > 1.0f) value = 1.0f;
          id(manual_pwm) = value;
  - platform: template
    name: "SA Startzeit (Min)"
    id: zeltlampe_sa_start_minutes
    unit_of_measurement: "min"
    min_value: 0
    max_value: 1439
    step: 15
    lambda: |-
      return id(sa_start_minutes);
    set_action:
      - lambda: |-
          id(sa_start_minutes) = (int) x;
  - platform: template
    name: "SU Startzeit (Min)"
    id: zeltlampe_su_start_minutes
    unit_of_measurement: "min"
    min_value: 0
    max_value: 1439
    step: 15
    lambda: |-
      return id(su_start_minutes);
    set_action:
      - lambda: |-
          id(su_start_minutes) = (int) x;
  - platform: template
    name: "Sonnenaufgang Dauer"
    id: zeltlampe_sunrise_duration
    unit_of_measurement: "min"
    min_value: 1
    max_value: 30
    step: 1
    lambda: |-
      return id(sunrise_min);
    set_action:
      - lambda: |-
          if (x < 1) x = 1;
          if (x > 30) x = 30;
          id(sunrise_min) = (int) x;
  - platform: template
    name: "Sonnenuntergang Dauer"
    id: zeltlampe_sunset_duration
    unit_of_measurement: "min"
    min_value: 1
    max_value: 30
    step: 1
    lambda: |-
      return id(sunset_min);
    set_action:
      - lambda: |-
          if (x < 1) x = 1;
          if (x > 30) x = 30;
          id(sunset_min) = (int) x;

interval:
  - interval: 30s
    then:
      - lambda: |-
          // Vereinfachte Lichtlogik für MANUAL/AUTO inklusive optionaler SA/SU-Rampe
          auto now = id(esphome_time).now();
          int mode = id(light_mode);  // 0=NONE, 1=MANUAL, 2=AUTO
          float manual_value = id(manual_pwm);
          if (manual_value < 0.0f) manual_value = 0.0f;
          if (manual_value > 1.0f) manual_value = 1.0f;
          float auto_value = id(max_pwm);
          if (auto_value < 0.1f) auto_value = 0.1f;
          if (auto_value > 1.0f) auto_value = 1.0f;
          float target_pwm = 0.0f;

          auto turn_light = [&](float brightness) {
            if (brightness <= 0.001f) {
              if (id(zeltlampe).current_values.is_on()) {
                id(zeltlampe).turn_off();
              }
            } else {
              auto call = id(zeltlampe).turn_on();
              call.set_brightness(brightness);
              call.perform();
            }
          };

          if (mode == 1) {
            // MANUAL
            target_pwm = manual_value;
          } else if (mode == 2) {
            // AUTO
            if (!now.is_valid()) {
              target_pwm = 0.0f;
            } else {
            auto normalize_minutes = [](int value) -> int {
              value %= 1440;
              if (value < 0) value += 1440;
              return value;
            };
            int minutes_of_day = now.hour * 60 + now.minute;
            int on_minute = normalize_minutes(id(on_minutes));
            int off_minute = normalize_minutes(id(off_minutes));
            int active_duration = off_minute - on_minute;
            if (active_duration <= 0) active_duration += 1440;
            if (active_duration <= 0) active_duration = 1440;
            int time_since_on = minutes_of_day - on_minute;
            if (time_since_on < 0) time_since_on += 1440;
            bool in_window = time_since_on < active_duration;

            if (!in_window) {
              target_pwm = 0.0f;
            } else if (!id(sun_ramp_enabled)) {
              // AUTO ohne SA/SU
              target_pwm = auto_value;
            } else {
              // AUTO mit SA/SU getrennten Startzeiten
              int sunrise_minutes = id(sunrise_min);
              int sunset_minutes = id(sunset_min);
              if (sunrise_minutes < 1) sunrise_minutes = 1;
              if (sunrise_minutes > 30) sunrise_minutes = 30;
              if (sunset_minutes < 1) sunset_minutes = 1;
              if (sunset_minutes > 30) sunset_minutes = 30;

              int sa_start = normalize_minutes(id(sa_start_minutes));
              int su_start = normalize_minutes(id(su_start_minutes));
              int sa_delta = minutes_of_day - sa_start;
              if (sa_delta < 0) sa_delta += 1440;
              int su_delta = minutes_of_day - su_start;
              if (su_delta < 0) su_delta += 1440;

              if (su_delta >= 0 && su_delta < sunset_minutes) {
                target_pwm = auto_value * (1.0f - (float) su_delta / sunset_minutes);
              } else if (sa_delta >= 0 && sa_delta < sunrise_minutes) {
                target_pwm = auto_value * (float) sa_delta / sunrise_minutes;
              } else {
                target_pwm = auto_value;
              }
            }
            }
          } else {
            // NONE
            target_pwm = 0.0f;
          }

          turn_light(target_pwm);


logger:

api:#
  encryption:
    key: !secret api_encryption_key
