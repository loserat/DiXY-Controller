# Core device metadata and boot-time sync behavior.
esphome:
  name: zeltsensor
  comment: "Minimalprofil BMP280 + AS7341"
  project:
    name: "loserat.dixy_zeltsensor"
    version: "2.8"
  # Sync the SA/SU toggle switch with the persisted flag on boot.
  on_boot:
    priority: -100
    then:
      - if:
          condition:
            lambda: 'return id(sun_ramp_enabled);'
          then:
            - switch.turn_on: zeltlampe_sun_ramp_switch
          else:
            - switch.turn_off: zeltlampe_sun_ramp_switch

# Time source for schedule-based logic.
time:
  - platform: sntp
    id: esphome_time

# Persisted state for light control and schedule parameters.
globals:
  # Mode selection: 0=NONE, 1=MANUAL, 2=AUTO
  - id: light_mode
    type: int
    restore_value: yes
    initial_value: '0'      # 0=NONE, 1=MANUAL, 2=AUTO
  # Time is stored internally as minutes since midnight for deterministic logic.
  # AUTO window start in minutes since midnight.
  - id: on_minutes
    type: int
    restore_value: yes
    initial_value: '480'    # 08:00 Uhr
  # AUTO window end in minutes since midnight.
  - id: off_minutes
    type: int
    restore_value: yes
    initial_value: '1200'   # 20:00 Uhr
  # Input_datetime from Home Assistant only feeds these values; ESP remains autonomous.
  # Maximum PWM for AUTO mode (0.0 - 1.0).
  - id: max_pwm
    type: float
    restore_value: yes
    initial_value: '1.0'
  # Fixed PWM for MANUAL mode (0.0 - 1.0).
  - id: manual_pwm
    type: float
    restore_value: yes
    initial_value: '0.5'
  # SA/SU start times in minutes since midnight.
  - id: sa_start_minutes
    type: int
    restore_value: yes
    initial_value: '480'
  - id: su_start_minutes
    type: int
    restore_value: yes
    initial_value: '1200'
  # Master enable for sunrise/sunset ramps.
  - id: sun_ramp_enabled
    type: bool
    restore_value: yes
    initial_value: 'false'
  # Sunrise and sunset ramp durations (minutes).
  - id: sunrise_min
    type: int
    restore_value: yes
    initial_value: '10'
  - id: sunset_min
    type: int
    restore_value: yes
    initial_value: '10'
  # CO2-SIMULATION (ENTFERNEN, sobald echte CO2-Hardware aktiv ist).
  - id: co2_dose_offset
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: co2_offset_last_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: co2_last_dose_check_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

# MCU target and framework.
esp32:
  board: esp32dev
  framework:
    type: arduino

# WiFi configuration + fallback AP.
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "ZELTSENSOR_Fallback"
    password: "12345678"


# OTA update configuration.
ota:
  platform: esphome
  password: !secret zeltsensor_ota_password

# I2C bus for sensors.
i2c:
  sda: 21
  scl: 22
  scan: true

# Sensor entities (dummy + real sensors).
sensor:
  # Home Assistant input_datetime feeds only the minutes source (no control logic here).
  # Home Assistant input_datetime: AUTO Einschaltzeit (hour/minute attributes).
  - platform: homeassistant
    id: auto_on_hour
    entity_id: input_datetime.einschaltzeit
    attribute: hour
    internal: true
    on_value:
      - lambda: |-
          if (isnan(id(auto_on_hour).state) || isnan(id(auto_on_minute).state)) {
            return;
          }
          int hour = (int) id(auto_on_hour).state;
          int minute = (int) id(auto_on_minute).state;
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(on_minutes) = hour * 60 + minute;
  - platform: homeassistant
    id: auto_on_minute
    entity_id: input_datetime.einschaltzeit
    attribute: minute
    internal: true
    on_value:
      - lambda: |-
          if (isnan(id(auto_on_hour).state) || isnan(id(auto_on_minute).state)) {
            return;
          }
          int hour = (int) id(auto_on_hour).state;
          int minute = (int) id(auto_on_minute).state;
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(on_minutes) = hour * 60 + minute;
  # Home Assistant input_datetime: AUTO Ausschaltzeit (hour/minute attributes).
  - platform: homeassistant
    id: auto_off_hour
    entity_id: input_datetime.ausschaltzeit
    attribute: hour
    internal: true
    on_value:
      - lambda: |-
          if (isnan(id(auto_off_hour).state) || isnan(id(auto_off_minute).state)) {
            return;
          }
          int hour = (int) id(auto_off_hour).state;
          int minute = (int) id(auto_off_minute).state;
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(off_minutes) = hour * 60 + minute;
  - platform: homeassistant
    id: auto_off_minute
    entity_id: input_datetime.ausschaltzeit
    attribute: minute
    internal: true
    on_value:
      - lambda: |-
          if (isnan(id(auto_off_hour).state) || isnan(id(auto_off_minute).state)) {
            return;
          }
          int hour = (int) id(auto_off_hour).state;
          int minute = (int) id(auto_off_minute).state;
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          if (minute < 0) minute = 0;
          if (minute > 59) minute = 59;
          id(off_minutes) = hour * 60 + minute;
  - platform: template
    name: "Blatttemperatur"
    id: leaf_temp_dummy
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state_class: measurement
    update_interval: 30s
    lambda: |-
      // Logic for "Blatttemperatur".
      static float leaf_temp = 26.0f;
      leaf_temp += (float((rand() % 7) - 3)) / 10.0f; // ±0.3°C
      if (leaf_temp < 20.0f) leaf_temp = 20.0f;
      if (leaf_temp > 32.0f) leaf_temp = 32.0f;
      return leaf_temp;
  # EC-Sensor (elektrische Leitfähigkeit)
  - platform: template
    name: "EC"
    id: ec_dummy
    unit_of_measurement: "mS/cm"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 10s
    lambda: |-
      // Logic for "EC".
      static float ec = 1.8f;
      ec += (float((rand() % 21) - 10)) / 100.0f; // ±0.10
      if (ec < 1.0f) ec = 1.0f;
      if (ec > 2.5f) ec = 2.5f;
      return ec;

  # --- Messsensoren (Sensoren-Tab in HA) ---
  - platform: template
    name: "Relative Luftfeuchte"
    id: rlf_dummy
    unit_of_measurement: "%"
    device_class: humidity
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      // Simuliere Tagesverlauf mit Sinusfunktion (max morgens, min nachmittags)
      auto t = id(esphome_time).now().hour + id(esphome_time).now().minute / 60.0;
      float amplitude = 20.0f; // Schwankung ±20%
      float base = 60.0f;      // Mittelwert
      float rlf = base + amplitude * sinf(3.14159 * (t - 6) / 12.0); // Maximum ca. 6 Uhr, Minimum ca. 18 Uhr
      if (rlf < 40.0f) rlf = 40.0f;
      if (rlf > 80.0f) rlf = 80.0f;
      return rlf;

  - platform: template
    name: "pH"
    id: ph_dummy
    unit_of_measurement: "pH"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 10s
    lambda: |-
      // Logic for "pH".
      static float ph = 6.2f;
      ph += (float((rand() % 21) - 10)) / 100.0f;
      if (ph < 5.5f) ph = 5.5f;
      if (ph > 7.0f) ph = 7.0f;
      return ph;

  - platform: template
    name: "CO2"
    id: co2_dummy
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    state_class: measurement
    update_interval: 30s
    lambda: |-
      // CO2-SIMULATION (ENTFERNEN, sobald echte CO2-Hardware aktiv ist).
      const float min_val = 400.0f;
      const float max_val = 2000.0f;
      const float mid = (min_val + max_val) * 0.5f;
      const float amp = (max_val - min_val) * 0.5f;
      const uint32_t period_ms = 900000UL;  // 15 min, schneller als andere Sensoren
      float phase = (float)(millis() % period_ms) / (float)period_ms;
      float base = mid + amp * sinf(phase * 2.0f * 3.1415926f);

      uint32_t now = millis();
      if (id(co2_offset_last_ms) == 0) {
        id(co2_offset_last_ms) = now;
      } else {
        uint32_t dt = now - id(co2_offset_last_ms);
        float decay_ms = 600000.0f;  // 10 min Ausklingen
        float factor = expf(-((float)dt) / decay_ms);
        id(co2_dose_offset) *= factor;
        id(co2_offset_last_ms) = now;
      }

      float co2 = base + id(co2_dose_offset);
      if (co2 < min_val) co2 = min_val;
      if (co2 > max_val) co2 = max_val;
      return co2;

  - platform: template
    name: "VPD"
    id: vpd_dummy
    unit_of_measurement: "kPa"
    accuracy_decimals: 2
    state_class: measurement
    update_interval: 30s
    lambda: |-
      // VPD-Berechnung aus Temperatur und Luftfeuchte
      float temp = 24.0f; // Platzhalterwert, kann durch echten Sensor ersetzt werden
      float rlf = 60.0f;  // Platzhalterwert, kann durch echten Sensor ersetzt werden
      float es = 0.6108 * exp((17.27 * temp) / (temp + 237.3));
      float ea = es * (rlf / 100.0f);
      float vpd = es - ea;
      return vpd;

  # Report current light brightness as a percent.
  - platform: template
    name: "Zeltlampe Helligkeit"
    id: zeltlampe_brightness_sensor
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    update_interval: 2s
    lambda: |-
      // Logic for "Zeltlampe Helligkeit".
      if (id(zeltlampe).current_values.is_on()) {
        return id(zeltlampe).current_values.get_brightness() * 100.0f;
      } else {
        return 0.0f;
      }

  # --- Diagnose-Sensoren (Diagnose-Tab in HA) ---
  - platform: bmp280_i2c
    address: 0x76
    temperature:
      name: "BMP280 Temperatur"
    pressure:
      name: "BMP280 Luftdruck"
    update_interval: 60s

  # --- AS7341 Spektralsensor: Alle Kanäle als Sensoren ---
  - platform: as7341
    address: 0x39
    id: as7341_sensor
    f1:
      name: "AS7341 F1 (415nm)"
      id: as7341_f1
    f2:
      name: "AS7341 F2 (445nm)"
      id: as7341_f2
    f3:
      name: "AS7341 F3 (480nm)"
      id: as7341_f3
    f4:
      name: "AS7341 F4 (515nm)"
      id: as7341_f4
    f5:
      name: "AS7341 F5 (555nm)"
      id: as7341_f5
    f6:
      name: "AS7341 F6 (590nm)"
      id: as7341_f6
    f7:
      name: "AS7341 F7 (630nm)"
      id: as7341_f7
    f8:
      name: "AS7341 F8 (680nm)"
      id: as7341_f8
    clear:
      name: "AS7341 Clear"
    nir:
      name: "AS7341 NIR"
    update_interval: 120s


  - platform: template
    name: "DS18B20"
    id: ds18b20_dummy
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      // Logic for "DS18B20".
      static float t = 22.0f;
      t += (float((rand() % 20) - 10)) / 10.0f;
      if (t < 20.0f) t = 20.0f;
      if (t > 25.0f) t = 25.0f;
      return t;

  - platform: wifi_signal
    name: "ESP WiFi Signal"
    id: wifi_strength
    update_interval: 60s

  - platform: uptime
    name: "ESP Uptime"
    update_interval: 60s

  - platform: template
    name: "PPFD (µmol/m²s)"
    id: ppfd
    unit_of_measurement: "µmol/m²s"
    lambda: |-
      // Logic for "PPFD (µmol/m²s)".
      return (id(as7341_f2).state + id(as7341_f3).state + id(as7341_f4).state + id(as7341_f5).state + id(as7341_f6).state + id(as7341_f7).state + id(as7341_f8).state) * 0.5;
    update_interval: 60s

  - platform: template
    name: "LUX (AS7341)"
    id: lux
    unit_of_measurement: "lx"
    lambda: |-
      // Logic for "LUX (AS7341)".
      return (id(as7341_f1).state + id(as7341_f2).state + id(as7341_f3).state + id(as7341_f4).state + id(as7341_f5).state + id(as7341_f6).state + id(as7341_f7).state + id(as7341_f8).state) * 2.0;
    update_interval: 60s

  - platform: template
    name: "DLI (mol/m²d)"
    id: dli
    unit_of_measurement: "mol/m²d"
    lambda: |-
      // Logic for "DLI (mol/m²d)".
      return id(ppfd).state * 0.0864;
    update_interval: 60s

# Text entities for time display and status.
text_sensor:
  # Geraetename fuer lokale Dashboards und Diagnose.
  - platform: template
    name: "Geraetename"
    id: zeltsensor_device_name
    icon: "mdi:identifier"
    entity_category: diagnostic
    lambda: |-
      // Logic for "Geraetename".
      return {"zeltsensor"};
    update_interval: 3600s
  # Aktueller Lichtmodus (AUS/AUTO/MANUELL).
  - platform: template
    name: "Zeltlampe Modus"
    id: zeltlampe_mode_text
    icon: "mdi:lightbulb"
    entity_category: diagnostic
    lambda: |-
      // Logic for "Zeltlampe Modus".
      switch (id(light_mode)) {
        case 1: return {"MANUELL"};
        case 2: return {"AUTO"};
        default: return {"AUS"};
      }
    update_interval: 30s
  # Aktuelle Lichtphase (Status-Only).
  - platform: template
    name: "Zeltlampe Aktuelle Phase"
    id: zeltlampe_phase_text
    icon: "mdi:progress-clock"
    entity_category: diagnostic
    lambda: |-
      // STATUS-ONLY – KEINE STEUERUNG
      // MANUELL HAT IMMER VORRANG
      int mode = id(light_mode);  // 0=NONE, 1=MANUAL, 2=AUTO
      if (mode == 1) {
        return {"MANUELL"};
      }
      if (mode == 2) {
        auto now = id(esphome_time).now();
        if (!now.is_valid()) {
          return {"AUS"};
        }
        auto normalize_minutes = [](int value) -> int {
          // Keep any minute value within 0..1439.
          value %= 1440;
          if (value < 0) value += 1440;
          return value;
        };
        int minutes_of_day = now.hour * 60 + now.minute;
        int on_minute = normalize_minutes(id(on_minutes));
        int off_minute = normalize_minutes(id(off_minutes));
        int active_duration = off_minute - on_minute;
        if (active_duration <= 0) active_duration += 1440;
        if (active_duration <= 0) active_duration = 1440;
        int time_since_on = minutes_of_day - on_minute;
        if (time_since_on < 0) time_since_on += 1440;
        bool in_window = time_since_on < active_duration;
        if (!in_window) {
          return {"AUS"};
        }
        if (!id(sun_ramp_enabled)) {
          return {"AUTO – PLATEAU"};
        }
        int sunrise_minutes = id(sunrise_min);
        int sunset_minutes = id(sunset_min);
        if (sunrise_minutes < 1) sunrise_minutes = 1;
        if (sunrise_minutes > 30) sunrise_minutes = 30;
        if (sunset_minutes < 1) sunset_minutes = 1;
        if (sunset_minutes > 30) sunset_minutes = 30;
        int sa_rel = normalize_minutes(id(sa_start_minutes) - on_minute);
        int su_rel = normalize_minutes(id(su_start_minutes) - on_minute);
        if (sa_rel >= active_duration) sa_rel = 0;
        if (su_rel == 0 || su_rel > active_duration) {
          su_rel = active_duration - sunset_minutes;
          if (su_rel < 0) su_rel = 0;
        }
        if (su_rel <= sa_rel) {
          su_rel = sa_rel + sunrise_minutes;
          if (su_rel > active_duration) {
            su_rel = active_duration;
          }
        }
        if (sa_rel + sunrise_minutes > su_rel) {
          sa_rel = su_rel - sunrise_minutes;
          if (sa_rel < 0) sa_rel = 0;
        }
        if (time_since_on < sa_rel) {
          return {"AUS"};
        } else if (time_since_on < sa_rel + sunrise_minutes) {
          return {"AUTO – SA"};
        } else if (time_since_on < su_rel) {
          return {"AUTO – PLATEAU"};
        } else if (time_since_on < su_rel + sunset_minutes) {
          return {"AUTO – SU"};
        }
        return {"AUS"};
      }
      return {"AUS"};
    update_interval: 30s
  # SA/SU Statusanzeige (nur Anzeige, keine Steuerung).
  - platform: template
    name: "SA/SU Status"
    id: sun_ramp_status_text
    icon: "mdi:weather-sunset"
    entity_category: diagnostic
    lambda: |-
      // Logic for "SA/SU Status".
      return id(sun_ramp_enabled) ? std::string("Aktiv") : std::string("Deaktiviert");
    update_interval: 30s
  - platform: template
    name: "AUTO Einschaltzeit"
    id: auto_on_time_display
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    lambda: |-
      // Logic for "AUTO Einschaltzeit".
      int minutes = id(on_minutes);
      if (minutes < 0 || minutes > 1439) {
        return {"--:--"};
      }
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    name: "AUTO Ausschaltzeit"
    id: auto_off_time_display
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    lambda: |-
      // Logic for "AUTO Ausschaltzeit".
      int minutes = id(off_minutes);
      if (minutes < 0 || minutes > 1439) {
        return {"--:--"};
      }
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    name: "SA Startzeit"
    id: sa_start_time_display
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    lambda: |-
      // Logic for "SA Startzeit".
      if (!id(sun_ramp_enabled)) {
        return {"Automatik deaktiviert"};
      }
      int minutes = id(sa_start_minutes);
      if (minutes < 0 || minutes > 1439) {
        return {"Automatik deaktiviert"};
      }
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    name: "SU Startzeit"
    id: su_start_time_display
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    lambda: |-
      // Logic for "SU Startzeit".
      if (!id(sun_ramp_enabled)) {
        return {"Automatik deaktiviert"};
      }
      int minutes = id(su_start_minutes);
      if (minutes < 0 || minutes > 1439) {
        return {"Automatik deaktiviert"};
      }
      int hour = minutes / 60;
      int minute = minutes % 60;
      char buffer[6];
      snprintf(buffer, sizeof(buffer), "%02d:%02d", hour, minute);
      return {buffer};
    update_interval: 60s
  - platform: template
    # Firmware-/Projektversion (Diagnoseanzeige).
    name: "Zeltsensor Version"
    id: zeltsensor_version
    icon: "mdi:tag"
    entity_category: diagnostic
    lambda: |-
      // Logic for "Zeltsensor Version".
      return {"v2.8"};
    update_interval: 3600s
  - platform: template
    name: "CO2 Dosierung Version"
    icon: "mdi:tag"
    entity_category: diagnostic
    lambda: |-
      return {"v0.1"};
    update_interval: 3600s
  - platform: template
    name: "Lichtsteuerung Version"
    icon: "mdi:tag"
    entity_category: diagnostic
    lambda: |-
      return {"v0.8"};
    update_interval: 3600s
  - platform: template
    name: "CO2 Differenz Sollwert"
    icon: "mdi:delta"
    entity_category: diagnostic
    lambda: |-
      float co2 = id(co2_dummy).state;
      float target = id(co2_target_ppm).state;
      if (isnan(co2) || isnan(target)) {
        return {"unavailable"};
      }
      float diff = co2 - target;
      char buffer[16];
      snprintf(buffer, sizeof(buffer), "%+.0f ppm", diff);
      return {buffer};
    update_interval: 10s
  - platform: wifi_info
    ip_address:
      name: "ESP IP Adresse"
    ssid:
      name: "ESP WiFi SSID"
    bssid:
      name: "ESP WiFi BSSID"
    mac_address:
      name: "ESP MAC Adresse"
# Basic device status.
binary_sensor:
  - platform: status
    name: "ESP Status"

# Onboard status LED.
status_led:
  pin: 2

# Outputs for PWM and template switch bridging.
output:
  - platform: ledc
    pin: 25
    id: zeltlampe_pwm
  # Bridge switch state into a persistent flag.
  - platform: template
    id: zeltlampe_sun_ramp_output
    type: binary
    write_action:
      - lambda: |-
          // Persist SA/SU enable state.
          id(sun_ramp_enabled) = state;

# Main light entity controlled by interval logic.
light:
  - platform: monochromatic
    name: "Zeltlampe"
    output: zeltlampe_pwm
    id: zeltlampe

# Switches for SA/SU enable and mode control.
switch:
  - platform: output
    name: "Zeltlampe SA/SU aktiv"
    id: zeltlampe_sun_ramp_switch
    icon: "mdi:weather-sunset"
    output: zeltlampe_sun_ramp_output
    restore_mode: RESTORE_DEFAULT_OFF
  # MANUELL hat Vorrang: beim Aktivieren wird AUTO deaktiviert.
  - platform: template
    name: "AUTO"
    id: auto_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          // AUTO enabled: set mode and disable MANUAL if needed.
          id(light_mode) = 2;
          if (id(manual_mode).state) {
            id(manual_mode).turn_off();
          }
    turn_off_action:
      - lambda: |-
          // AUTO disabled: clear mode if MANUAL is also off.
          if (!id(manual_mode).state) {
            id(light_mode) = 0;
          }
    lambda: |-
      // Logic for "AUTO".
      return id(light_mode) == 2;
  - platform: template
    name: "MANUELL"
    id: manual_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          // MANUAL enabled: set mode and disable AUTO if needed.
          id(light_mode) = 1;
          if (id(auto_mode).state) {
            id(auto_mode).turn_off();
          }
    turn_off_action:
      - lambda: |-
          // MANUAL disabled: clear mode if AUTO is also off.
          if (!id(auto_mode).state) {
            id(light_mode) = 0;
          }
    lambda: |-
      // Logic for "MANUELL".
      return id(light_mode) == 1;
  - platform: template
    name: "CO2 Automatik"
    id: co2_auto
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_off_action:
      - switch.turn_off: co2_dose_output
  - platform: template
    name: "CO2 Dosierung"
    id: co2_dose_output
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          // CO2-SIMULATION (ENTFERNEN, sobald echte CO2-Hardware aktiv ist).
          id(co2_dose_offset) += 60.0f;
          if (id(co2_dose_offset) > 400.0f) id(co2_dose_offset) = 400.0f;

# User-adjustable parameters (brightness and timings).
number:
  # User-adjustable parameters for lighting behavior.
  - platform: template
    name: "AUTO Einschaltzeit (Min)"
    id: auto_on_minutes_local
    unit_of_measurement: "min"
    min_value: 0
    max_value: 1439
    step: 5
    lambda: |-
      // Logic for "AUTO Einschaltzeit (Min)".
      return id(on_minutes);
    set_action:
      - lambda: |-
          int value = (int) x;
          if (value < 0) value = 0;
          if (value > 1439) value = 1439;
          id(on_minutes) = value;
  - platform: template
    name: "AUTO Ausschaltzeit (Min)"
    id: auto_off_minutes_local
    unit_of_measurement: "min"
    min_value: 0
    max_value: 1439
    step: 5
    lambda: |-
      // Logic for "AUTO Ausschaltzeit (Min)".
      return id(off_minutes);
    set_action:
      - lambda: |-
          int value = (int) x;
          if (value < 0) value = 0;
          if (value > 1439) value = 1439;
          id(off_minutes) = value;
  - platform: template
    name: "Auto Max Helligkeit"
    id: zeltlampe_max_pwm
    unit_of_measurement: "%"
    min_value: 10
    max_value: 100
    step: 1
    lambda: |-
      // Logic for "Auto Max Helligkeit".
      return id(max_pwm) * 100.0f;
    set_action:
      - lambda: |-
          float value = x / 100.0f;
          if (value < 0.0f) value = 0.0f;
          if (value > 1.0f) value = 1.0f;
          id(max_pwm) = value;
  - platform: template
    name: "Manuelle Helligkeit"
    id: zeltlampe_manual_pwm
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    lambda: |-
      // Logic for "Manuelle Helligkeit".
      return id(manual_pwm) * 100.0f;
    set_action:
      - lambda: |-
          float value = x / 100.0f;
          if (value < 0.0f) value = 0.0f;
          if (value > 1.0f) value = 1.0f;
          id(manual_pwm) = value;
  # SA/SU ramp durations in minutes.
  - platform: template
    name: "Sonnenaufgang Dauer"
    id: zeltlampe_sunrise_duration
    unit_of_measurement: "min"
    min_value: 1
    max_value: 30
    step: 1
    lambda: |-
      // Logic for "Sonnenaufgang Dauer".
      return id(sunrise_min);
    set_action:
      - lambda: |-
          if (x < 1) x = 1;
          if (x > 30) x = 30;
          id(sunrise_min) = (int) x;
  - platform: template
    name: "Sonnenuntergang Dauer"
    id: zeltlampe_sunset_duration
    unit_of_measurement: "min"
    min_value: 1
    max_value: 30
    step: 1
    lambda: |-
      // Logic for "Sonnenuntergang Dauer".
      return id(sunset_min);
    set_action:
      - lambda: |-
          if (x < 1) x = 1;
          if (x > 30) x = 30;
          id(sunset_min) = (int) x;
  - platform: template
    name: "CO2 Sollwert"
    id: co2_target_ppm
    unit_of_measurement: "ppm"
    optimistic: true
    min_value: 400
    max_value: 2000
    step: 100
    initial_value: 1000
    restore_value: true
  - platform: template
    name: "CO2 Hysterese"
    id: co2_hysteresis_ppm
    unit_of_measurement: "ppm"
    optimistic: true
    min_value: 100
    max_value: 500
    step: 100
    initial_value: 100
    restore_value: true

# Main control loop for light logic.
interval:
  - interval: 30s
    then:
      - lambda: |-
          // ZENTRALE ZEITLOGIK
          // NICHT ÄNDERN – Grundlage für AUTO/SA/SU
          // ERWEITERUNG HIER MÖGLICH
          // Vereinfachte Lichtlogik für MANUAL/AUTO inklusive optionaler SA/SU-Rampe
          auto now = id(esphome_time).now();
          // Clamp inputs and prepare target PWM.
          int mode = id(light_mode);  // 0=NONE, 1=MANUAL, 2=AUTO
          float manual_value = id(manual_pwm);
          if (manual_value < 0.0f) manual_value = 0.0f;
          if (manual_value > 1.0f) manual_value = 1.0f;
          float auto_value = id(max_pwm);
          if (auto_value < 0.1f) auto_value = 0.1f;
          if (auto_value > 1.0f) auto_value = 1.0f;
          float target_pwm = 0.0f;

          // Always hard-toggle the light entity based on computed PWM.
          auto turn_light = [&](float brightness) {
            if (brightness <= 0.001f) {
              if (id(zeltlampe).current_values.is_on()) {
                id(zeltlampe).turn_off();
              }
            } else {
              auto call = id(zeltlampe).turn_on();
              call.set_brightness(brightness);
              call.perform();
            }
          };

          if (mode == 1) {
            // MANUAL
            target_pwm = manual_value;
          } else if (mode == 2) {
            // AUTO
            if (!now.is_valid()) {
              target_pwm = 0.0f;
            } else {
            auto normalize_minutes = [](int value) -> int {
              // Keep any minute value within 0..1439.
              value %= 1440;
              if (value < 0) value += 1440;
              return value;
            };
            int minutes_of_day = now.hour * 60 + now.minute;
            int on_minute = normalize_minutes(id(on_minutes));
            int off_minute = normalize_minutes(id(off_minutes));
            // Compute active window length across midnight if needed.
            int active_duration = off_minute - on_minute;
            if (active_duration <= 0) active_duration += 1440;
            if (active_duration <= 0) active_duration = 1440;
            int time_since_on = minutes_of_day - on_minute;
            if (time_since_on < 0) time_since_on += 1440;
            bool in_window = time_since_on < active_duration;

            if (!in_window) {
              target_pwm = 0.0f;
            } else if (!id(sun_ramp_enabled)) {
              // AUTO ohne SA/SU
              target_pwm = auto_value;
            } else {
              // AUTO mit SA/SU getrennten Startzeiten
              int sunrise_minutes = id(sunrise_min);
              int sunset_minutes = id(sunset_min);
              if (sunrise_minutes < 1) sunrise_minutes = 1;
              if (sunrise_minutes > 30) sunrise_minutes = 30;
              if (sunset_minutes < 1) sunset_minutes = 1;
              if (sunset_minutes > 30) sunset_minutes = 30;

              int sa_rel = normalize_minutes(id(sa_start_minutes) - on_minute);
              int su_rel = normalize_minutes(id(su_start_minutes) - on_minute);

              if (sa_rel >= active_duration) sa_rel = 0;
              if (su_rel == 0 || su_rel > active_duration) {
                su_rel = active_duration - sunset_minutes;
                if (su_rel < 0) su_rel = 0;
              }

              if (su_rel <= sa_rel) {
                su_rel = sa_rel + sunrise_minutes;
                if (su_rel > active_duration) {
                  su_rel = active_duration;
                }
              }

              if (sa_rel + sunrise_minutes > su_rel) {
                sa_rel = su_rel - sunrise_minutes;
                if (sa_rel < 0) sa_rel = 0;
              }

              if (time_since_on < sa_rel) {
                target_pwm = 0.0f;
              } else if (time_since_on < sa_rel + sunrise_minutes) {
                int ramp_pos = time_since_on - sa_rel;
                target_pwm = auto_value * (float) ramp_pos / sunrise_minutes;
              } else if (time_since_on < su_rel) {
                target_pwm = auto_value;
              } else if (time_since_on < su_rel + sunset_minutes) {
                int ramp_pos = time_since_on - su_rel;
                target_pwm = auto_value * (1.0f - (float) ramp_pos / sunset_minutes);
              } else {
                target_pwm = 0.0f;
              }
            }
            }
          } else {
            // NONE
            target_pwm = 0.0f;
          }

          // ESP entscheidet autark und setzt die Light-Entity deterministisch.
          turn_light(target_pwm);
  - interval: 10s
    then:
      - lambda: |-
          if (!id(co2_auto).state) {
            return;
          }
          float co2 = id(co2_dummy).state;
          if (isnan(co2)) {
            return;
          }
          float target = id(co2_target_ppm).state;
          float hysteresis = id(co2_hysteresis_ppm).state;
          if (co2 < target - hysteresis) {
            id(co2_dose_output).turn_on();
          } else if (co2 > target + hysteresis) {
            id(co2_dose_output).turn_off();
          }
  - interval: 10min
    then:
      - lambda: |-
          // CO2-SIMULATION (ENTFERNEN, sobald echte CO2-Hardware aktiv ist).
          uint32_t now = millis();
          if (id(co2_last_dose_check_ms) == 0) {
            id(co2_last_dose_check_ms) = now;
            return;
          }
          if (now - id(co2_last_dose_check_ms) < 600000UL) {
            return;
          }
          id(co2_last_dose_check_ms) = now;
          if (id(co2_dose_output).state) {
            id(co2_dose_offset) += 80.0f;
            if (id(co2_dose_offset) > 500.0f) id(co2_dose_offset) = 500.0f;
          }

# Serial/logger configuration.
logger:
  level: Info

# Native API for Home Assistant.
api:
  encryption:
    key: !secret api_encryption_key

# Lokales ESP-Web-Dashboard (Anzeige der Sensoren per IP).
web_server:
  # Anzeige-Only gedacht: Steuerung erfolgt weiterhin durch ESP-Logik.
  port: 80
