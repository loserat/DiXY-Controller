[
  {
    "id": "tab_light_logic",
    "type": "tab",
    "label": "03_Light_Logic",
    "disabled": false
  },
  {
    "id": "ha_server_cfg_light",
    "type": "server",
    "name": "Home Assistant",
    "addon": false,
    "rejectUnauthorizedCerts": true,
    "version": 6,
    "connectionDelay": true,
    "cacheJson": true
  },
  {
    "id": "mqtt_local_cfg_light",
    "type": "mqtt-broker",
    "name": "MQTT Local",
    "broker": "localhost",
    "port": "1883",
    "clientid": "dixy-node-red",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": 4,
    "keepalive": "60",
    "cleansession": true,
    "autoUnsubscribe": true
  },
  {
    "id": "state_light_helpers",
    "type": "server-state-changed",
    "z": "tab_light_logic",
    "name": "Light helpers & sensors",
    "server": "ha_server_cfg_light",
    "version": 3,
    "exposeToHomeAssistant": false,
    "entityidfiltertype": "regex",
    "entityidfilter": "(input_select\\.light_mode|input_datetime\\.light_manual_on_time|input_datetime\\.light_manual_off_time|input_number\\.light_manual_intensity|input_number\\.light_ppfd_target|input_number\\.light_ppfd_min_percent|input_number\\.light_ppfd_max_percent|input_number\\.light_ppfd_hysteresis|number\\.zeltsensor_v2_light_intensity|sensor\\.zeltsensor_ppfd)",
    "outputinitially": true,
    "state_type": "str",
    "output_only_on_state_change": true,
    "for": "0",
    "forType": "num",
    "forUnits": "minutes",
    "ignorePrevStateNull": false,
    "outputProperties": [
      { "property": "payload", "propertyType": "msg", "value": "", "valueType": "entityState" },
      { "property": "entity_id", "propertyType": "msg", "value": "", "valueType": "entityId" }
    ],
    "x": 210,
    "y": 100,
    "wires": [["fn_store_light_ctx"]]
  },
  {
    "id": "fn_store_light_ctx",
    "type": "function",
    "z": "tab_light_logic",
    "name": "Store light context",
    "func": "const ctx = flow.get(\"light\") || {};\nctx[msg.entity_id] = msg.payload;\nflow.set(\"light\", ctx);\nreturn null;\n",
    "outputs": 0,
    "noerr": 0,
    "x": 480,
    "y": 100,
    "wires": []
  },
  {
    "id": "tick_light",
    "type": "inject",
    "z": "tab_light_logic",
    "name": "Check every 1 min",
    "props": [],
    "repeat": "60",
    "crontab": "",
    "once": true,
    "onceDelay": 5,
    "topic": "",
    "x": 170,
    "y": 180,
    "wires": [["fn_light_logic"]]
  },
  {
    "id": "fn_light_logic",
    "type": "function",
    "z": "tab_light_logic",
    "name": "Light control logic",
    "func": "function timeToMinutes(hhmm) {\n  if (!hhmm) return null;\n  const parts = hhmm.split(\":\");\n  if (parts.length < 2) return null;\n  return Number(parts[0]) * 60 + Number(parts[1]);\n}\nfunction withinWindow(nowMin, onMin, offMin) {\n  if (onMin === null || offMin === null) return true; // no window -> allow\n  if (onMin <= offMin) {\n    return nowMin >= onMin && nowMin < offMin;\n  }\n  // crosses midnight\n  return nowMin >= onMin || nowMin < offMin;\n}\n\nconst ctx = flow.get(\"light\") || {};\nconst mode = ctx[\"input_select.light_mode\"] || \"Aus\";\nconst now = new Date();\nconst nowMin = now.getHours() * 60 + now.getMinutes();\nconst onMin = timeToMinutes(ctx[\"input_datetime.light_manual_on_time\"]);\nconst offMin = timeToMinutes(ctx[\"input_datetime.light_manual_off_time\"]);\nconst inWindow = withinWindow(nowMin, onMin, offMin);\n\nlet level = 0;\nlet reason = \"off\";\nif (mode === \"Aus\") {\n  level = 0;\n  reason = \"mode off\";\n} else if (!inWindow) {\n  level = 0;\n  reason = \"outside window\";\n} else if (mode === \"Manuell\") {\n  level = Number(ctx[\"input_number.light_manual_intensity\"] || 80);\n  reason = \"manual\";\n} else if (mode === \"Auto (Sonnenauf-/untergang)\") {\n  // Vereinfachung: nutze manuelle On/Off Zeiten als Fenster, gleiche IntensitÃ¤t wie manuell\n  level = Number(ctx[\"input_number.light_manual_intensity\"] || 80);\n  reason = \"auto window\";\n} else if (mode === \"PPFD-Regelung\") {\n  const ppfd = Number(ctx[\"sensor.zeltsensor_ppfd\"] || 0);\n  const target = Number(ctx[\"input_number.light_ppfd_target\"] || 0);\n  const hyst = Number(ctx[\"input_number.light_ppfd_hysteresis\"] || 50);\n  let curr = Number(ctx[\"number.zeltsensor_v2_light_intensity\"] || 50);\n  const minP = Number(ctx[\"input_number.light_ppfd_min_percent\"] || 10);\n  const maxP = Number(ctx[\"input_number.light_ppfd_max_percent\"] || 100);\n  if (!target || !ppfd) {\n    level = curr;\n    reason = \"ppfd missing\";\n  } else if (ppfd < target - hyst) {\n    level = Math.min(maxP, curr + 5);\n    reason = \"ppfd low\";\n  } else if (ppfd > target + hyst) {\n    level = Math.max(minP, curr - 5);\n    reason = \"ppfd high\";\n  } else {\n    level = curr;\n    reason = \"ppfd ok\";\n  }\n} else {\n  level = 0;\n  reason = \"unknown mode\";\n}\n\n// clamp\nlevel = Math.max(0, Math.min(100, level));\n\n// Build command\nlet payload;\nif (level <= 0) {\n  payload = \"off\";\n} else {\n  payload = { level };\n}\nreturn { topic: \"dixy/light/cmd\", payload, reason };\n",
    "outputs": 1,
    "noerr": 0,
    "x": 430,
    "y": 180,
    "wires": [["mqtt_out_light"]]
  },
  {
    "id": "mqtt_out_light",
    "type": "mqtt out",
    "z": "tab_light_logic",
    "name": "Publish Light Cmd",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_local_cfg_light",
    "x": 700,
    "y": 180,
    "wires": []
  }
]
