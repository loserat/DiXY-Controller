[
  {
    "id": "tab_light_logic_sunfade",
    "type": "tab",
    "label": "03_Light_Logic_Sunfade",
    "disabled": false
  },
  {
    "id": "ha_server_cfg_light_sunfade",
    "type": "server",
    "name": "Home Assistant",
    "addon": false,
    "rejectUnauthorizedCerts": true,
    "version": 6,
    "connectionDelay": true,
    "cacheJson": true
  },
  {
    "id": "mqtt_local_cfg_light_sunfade",
    "type": "mqtt-broker",
    "name": "MQTT Local",
    "broker": "localhost",
    "port": "1883",
    "clientid": "dixy-node-red",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": 4,
    "keepalive": "60",
    "cleansession": true,
    "autoUnsubscribe": true
  },
  {
    "id": "state_light_helpers_sunfade",
    "type": "server-state-changed",
    "z": "tab_light_logic_sunfade",
    "name": "Light helpers & sensors",
    "server": "ha_server_cfg_light_sunfade",
    "version": 3,
    "exposeToHomeAssistant": false,
    "entityidfiltertype": "regex",
    "entityidfilter": "(input_select\\.light_mode|input_datetime\\.light_manual_on_time|input_datetime\\.light_manual_off_time|input_number\\.light_manual_intensity|input_number\\.light_ppfd_target|input_number\\.light_ppfd_min_percent|input_number\\.light_ppfd_max_percent|input_number\\.light_ppfd_hysteresis|input_number\\.light_auto_sunrise_offset|input_number\\.light_auto_sunset_offset|input_number\\.light_fade_duration|number\\.zeltsensor_v2_light_intensity|sensor\\.zeltsensor_ppfd|sensor\\.sun_sunrise|sensor\\.sun_sunset)",
    "outputinitially": true,
    "state_type": "str",
    "output_only_on_state_change": true,
    "for": "0",
    "forType": "num",
    "forUnits": "minutes",
    "ignorePrevStateNull": false,
    "outputProperties": [
      { "property": "payload", "propertyType": "msg", "value": "", "valueType": "entityState" },
      { "property": "entity_id", "propertyType": "msg", "value": "", "valueType": "entityId" }
    ],
    "x": 210,
    "y": 100,
    "wires": [["fn_store_light_ctx_sunfade"]]
  },
  {
    "id": "fn_store_light_ctx_sunfade",
    "type": "function",
    "z": "tab_light_logic_sunfade",
    "name": "Store light context",
    "func": "const ctx = flow.get(\"light\") || {};\nctx[msg.entity_id] = msg.payload;\nflow.set(\"light\", ctx);\nreturn null;\n",
    "outputs": 0,
    "noerr": 0,
    "x": 480,
    "y": 100,
    "wires": []
  },
  {
    "id": "tick_light_sunfade",
    "type": "inject",
    "z": "tab_light_logic_sunfade",
    "name": "Check every 1 min",
    "props": [],
    "repeat": "60",
    "crontab": "",
    "once": true,
    "onceDelay": 5,
    "topic": "",
    "x": 170,
    "y": 180,
    "wires": [["fn_light_logic_sunfade"]]
  },
  {
    "id": "fn_light_logic_sunfade",
    "type": "function",
    "z": "tab_light_logic_sunfade",
    "name": "Light control logic (sunrise/sunset + fade + PPFD)",
    "func": "function timeToMinutes(hhmm) {\n  if (!hhmm) return null;\n  const p = hhmm.split(\":\");\n  if (p.length < 2) return null;\n  return Number(p[0]) * 60 + Number(p[1]);\n}\nfunction withinWindow(nowMin, onMin, offMin) {\n  if (onMin === null || offMin === null) return true; // kein Fenster -> immer an\n  if (onMin <= offMin) return nowMin >= onMin && nowMin < offMin;\n  return nowMin >= onMin || nowMin < offMin; // Ã¼ber Mitternacht\n}\nfunction isoToMinutes(isoStr) {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  if (isNaN(d)) return null;\n  return d.getUTCHours() * 60 + d.getUTCMinutes();\n}\n\nconst ctx = flow.get(\"light\") || {};\nconst mode = ctx[\"input_select.light_mode\"] || \"Aus\";\nconst now = new Date();\nconst nowMin = now.getHours() * 60 + now.getMinutes();\n\nconst manualOn = timeToMinutes(ctx[\"input_datetime.light_manual_on_time\"]);\nconst manualOff = timeToMinutes(ctx[\"input_datetime.light_manual_off_time\"]);\nconst baseIntensity = Number(ctx[\"input_number.light_manual_intensity\"] || 80);\nconst sunriseOffset = Number(ctx[\"input_number.light_auto_sunrise_offset\"] || 0);\nconst sunsetOffset = Number(ctx[\"input_number.light_auto_sunset_offset\"] || 0);\nconst fadeSecRaw = Number(ctx[\"input_number.light_fade_duration\"] || 300);\nconst fadeSec = Math.max(60, Math.min(1800, fadeSecRaw));\nconst fadeMin = Math.max(1, Math.round(fadeSec / 60));\n\n// Sunrise/Sunset aus sensor.sun_* (UTC) + Offset\nlet sunRiseMin = isoToMinutes(ctx[\"sensor.sun_sunrise\"]);\nlet sunSetMin = isoToMinutes(ctx[\"sensor.sun_sunset\"]);\nif (sunRiseMin !== null) sunRiseMin = (sunRiseMin + sunriseOffset + 1440) % 1440;\nif (sunSetMin !== null) sunSetMin = (sunSetMin + sunsetOffset + 1440) % 1440;\n\n// Fallback: manuelle Zeiten, falls Sun fehlt\nconst onMin = sunRiseMin !== null ? sunRiseMin : manualOn;\nconst offMin = sunSetMin !== null ? sunSetMin : manualOff;\nconst inWindow = withinWindow(nowMin, onMin, offMin);\n\nlet level = 0;\nlet reason = \"off\";\n\nif (mode === \"Aus\") {\n  level = 0; reason = \"mode off\";\n} else if (!inWindow) {\n  level = 0; reason = \"outside window\";\n} else if (mode === \"Manuell\") {\n  level = baseIntensity; reason = \"manual\";\n} else if (mode === \"Auto (Sonnenauf-/untergang)\") {\n  // linear fade um onMin/offMin herum\n  const startFadeIn = onMin !== null ? (onMin - fadeMin + 1440) % 1440 : null;\n  const endFadeIn = onMin;\n  const startFadeOut = offMin;\n  const endFadeOut = offMin !== null ? (offMin + fadeMin) % 1440 : null;\n\n  function fadeFactor(start, end) {\n    if (start === null || end === null) return null;\n    if (start < end) {\n      if (nowMin < start || nowMin > end) return null;\n      return (nowMin - start) / (end - start);\n    }\n    const span = (end + 1440 - start) % 1440;\n    let dist = (nowMin + 1440 - start) % 1440;\n    if (dist > span) return null;\n    return dist / span;\n  }\n\n  const fIn = fadeFactor(startFadeIn, endFadeIn);\n  const fOut = fadeFactor(startFadeOut, endFadeOut);\n  if (fIn !== null && nowMin !== endFadeOut) {\n    level = Math.round(baseIntensity * Math.max(0, Math.min(1, fIn)));\n    reason = \"fade in\";\n  } else if (fOut !== null) {\n    level = Math.round(baseIntensity * (1 - Math.max(0, Math.min(1, fOut))));\n    reason = \"fade out\";\n  } else {\n    level = baseIntensity; reason = \"auto steady\";\n  }\n} else if (mode === \"PPFD-Regelung\") {\n  const ppfd = Number(ctx[\"sensor.zeltsensor_ppfd\"] || 0);\n  const target = Number(ctx[\"input_number.light_ppfd_target\"] || 0);\n  const hyst = Number(ctx[\"input_number.light_ppfd_hysteresis\"] || 50);\n  let curr = Number(ctx[\"number.zeltsensor_v2_light_intensity\"] || baseIntensity);\n  const minP = Number(ctx[\"input_number.light_ppfd_min_percent\"] || 10);\n  const maxP = Number(ctx[\"input_number.light_ppfd_max_percent\"] || 100);\n  if (!target || !ppfd) {\n    level = curr; reason = \"ppfd missing\";\n  } else if (ppfd < target - hyst) {\n    level = Math.min(maxP, curr + 5); reason = \"ppfd low\";\n  } else if (ppfd > target + hyst) {\n    level = Math.max(minP, curr - 5); reason = \"ppfd high\";\n  } else {\n    level = curr; reason = \"ppfd ok\";\n  }\n} else {\n  level = 0; reason = \"unknown mode\";\n}\n\nlevel = Math.max(0, Math.min(100, level));\nconst payload = level <= 0 ? \"off\" : { level };\nreturn { topic: \"dixy/light/cmd\", payload, reason };\n",
    "outputs": 1,
    "noerr": 0,
    "x": 460,
    "y": 180,
    "wires": [["mqtt_out_light_sunfade"]]
  },
  {
    "id": "mqtt_out_light_sunfade",
    "type": "mqtt out",
    "z": "tab_light_logic_sunfade",
    "name": "Publish Light Cmd",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_local_cfg_light_sunfade",
    "x": 740,
    "y": 180,
    "wires": []
  }
]
